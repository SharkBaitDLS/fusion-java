// Copyright (c) 2012 Amazon.com, Inc.  All rights reserved.

(module check 'fusion/base'

  (use 'fusion/experimental/defines')
  (use 'fusion/ffi/java')
  (use 'fusion/ion')
  (use 'fusion/list')
  (use 'fusion/syntax')
  (use 'fusion/vector')


  // NOT PUBLIC YET
  (define raise_check_failure (java_new "com.amazon.fusion.CheckFailureProc"))


  (defpub check_equal_annotations
    (lambda (actual expected)
      (check_vector_equal (ion_annotations actual) (ion_annotations expected))))

  (defpub check_equal
    (lambda (actual expected descr)
      (cond

// TODO FUSION-88 should support undef
//        ((is_undef expected)
//         (assert (is_undef actual)
//           descr " not equal.\nActual: " actual "\nExpected: " expected))
        ((is_list expected)
         (check_list_equal actual expected))
        ((is_vector expected)
         (check_vector_equal actual expected))
        ((is_void expected)
         (assert (is_void actual)
           descr " not equal.\nActual: " actual "\nExpected: " expected))
        (true
         (assert (= actual expected)
           descr " not equal.\nActual: " actual "\nExpected: " expected)))
      (check_equal_annotations actual expected)))

  (defpub check_list_equal
    (lambda (actual expected)
      (assert (is_list actual) "expected list, received: " actual)
      (assert (= (size actual) (size expected))
        "list lengths don't match. Actual: " actual " Expected: " expected)
      (let loop ((i 0))
        (when (< i (size actual))
          (check_equal (. actual i) (. expected i) "list element") // TODO bad descr
          (loop (+ 1 i))))))

  (defpub check_vector_equal
    (lambda (actual expected)
      (assert (is_vector actual) "expected vector, received: " actual)
      (assert (= (vector_size actual) (vector_size expected))
        "vector sizes don't match. Actual: " actual " Expected: " expected)
      (let loop ((i 0))
        (when (< i (vector_size actual))
          (check_equal (vector_ref actual i) (vector_ref expected i)
            "vector element") // TODO bad descr
          (loop (+ 1 i))))))


  (defpub check_annotations
    (lambda (value expected)
      (let ((anns (ion_annotations value)))
        (check_list_equal anns expected))))


/* This is nowhere near working yet...
  (defpub_syntax define_simple_check
    (lambda (stx)
      (let ((bindings (syntax_get stx 1))
            (body_sexp (syntax_subseq stx 2)))
        (let ((name (syntax_get bindings 0))
              (params (syntax_subseq bindings 1))
              (body_begin (syntax_cons_q begin body_sexp)))

          (quasisyntax
            (define (unsyntax name)
              (lambda (stx)

              )))))))
*/

  (define_syntax do_check  // private
    (lambda (stx)
      '''
(do_check ORIG_STX OP VAL1 VAL2 MSG ...)

Ensures that (OP VAL1 VAL2) is truthy.
      '''
      (let ((orig_stx (syntax_get stx 1))
            (op_stx   (syntax_get stx 2))
            (val1_stx (syntax_get stx 3))
            (val2_stx (syntax_get stx 4))
            (msg_sexp (syntax_subseq stx 5)))
        (quasisyntax
          (let ((op   (unsyntax op_stx))
                (val1 (unsyntax val1_stx))
                (val2 (unsyntax val2_stx)))
            (unless (op val1 val2)
              (unsyntax
                (syntax_append
                  (quasisyntax
                    (raise_check_failure
                      (quote_syntax (unsyntax orig_stx))))
                  msg_sexp
                  (quasisyntax
                    ("\n params:\n  " op
                     "\n  " val1
                     "\n  " val2))))))))))

  (defpub_syntax check
    (lambda (stx)
      '''
(check OP VAL1 VAL2 MSG ...)

Ensures that (OP VAL1 VAL2) is truthy.
      '''
      (when (< (syntax_size stx) 4)
        (wrong_syntax stx "check requires at least three args: (check OP VAL1 VAL2 MSG ...)"))
      (syntax_append
        (quasisyntax (do_check (unsyntax stx)))
        (syntax_subseq stx 1))))


  // The failure message isn't the greatest, its in terms of the inner check
  (defpub_syntax check_true
    (lambda (stx)
      (let ((val1_stx (syntax_get stx 1))
            (msg_sexp (syntax_subseq stx 2)))
        (syntax_append
          (quasisyntax
            (do_check (unsyntax stx) = (unsyntax val1_stx) true))
          msg_sexp))))


  // The failure message isn't the greatest, its in terms of the inner check
  (defpub_syntax check_false
    (lambda (stx)
      (let ((val1_stx (syntax_get stx 1))
            (msg_sexp (syntax_subseq stx 2)))
        (syntax_append
          (quasisyntax
            (do_check (unsyntax stx) = (unsyntax val1_stx) false))
          msg_sexp))))
)

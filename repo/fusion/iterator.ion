// Copyright (c) 2012 Amazon.com, Inc.  All rights reserved.

(module iterator 'fusion/base'
  (use 'fusion/ffi/java')
  (use 'fusion/experimental/defines')

  (define TRUE  (lambda () true))
  (define FALSE (lambda () false))

  (define BAD_NEXT
    (lambda ()
      (assert false "no such element")))


  (defpub_j is_iterator       "com.amazon.fusion.FusionIterator$IsIteratorProc")
  (defpub_j iterate_list      "com.amazon.fusion.IterateListProc")
  (defpub_j iterator_has_next "com.amazon.fusion.FusionIterator$HasNextProc")
  (defpub_j iterator_next     "com.amazon.fusion.FusionIterator$NextProc")


  (defpub make_iterator
    (lambda (has_next_proc next_proc)
       (java_new "com.amazon.fusion.FusionIterator" has_next_proc next_proc)))

  (defpub empty_iterator
    (make_iterator FALSE (lambda () undef)))
  // TODO (next) should throw an exception


  (defpub iterate_value
    (lambda (value)
      (letrec ((has_next TRUE)
               (next (lambda ()
                       (set has_next FALSE)
                       (set next BAD_NEXT)
                       value)))
        (make_iterator
          (lambda () (has_next))
          (lambda () (next))))))


  (defpub iterator_to_list
    (lambda (iter)
      '''
Creates a list with the contents of ITERATOR, in the same order.
      '''
      (unless (is_iterator iter)
        (raise_argument_error "iterator_to_list" "iterator" 0 iter))
      (let loop ((result []))
        (if (iterator_has_next iter)
          (loop (add result (iterator_next iter)))
          result))))


  (defpub iterator_map
    (lambda (proc iter)
      '''
Returns a lazy iterator that contains PROC applied to each element of ITER.
      '''
      // TODO type-check proc
      (unless (is_iterator iter)
        (raise_argument_error "iterator_map" "iterator" 1 proc iter))
      (make_iterator
        (lambda () (iterator_has_next iter))
        (lambda () (proc (iterator_next iter))))))

  // AKA cross-apply
  (defpub iterator_map_splicing
    (lambda (proc iter)
      '''
Returns an iterator that applies an iterator-making PROC to each element of
ITER, splicing the inner sequences into a single outer sequence.
      '''
      // TODO type-check proc
      (unless (is_iterator iter)
        (raise_argument_error "iterator_map_splicing" "iterator" 1 proc iter))
      (letrec [(find_next
                 (lambda ()
                   (if (iterator_has_next iter)
                     (let [(inner_iter (proc (iterator_next iter)))]
                       (unless (is_iterator inner_iter)
                         (raise_result_error "iterator_map_splicing"
                            "iterator from mapping procedure"
                            inner_iter))
                       (letrec [(inner_find_next
                                  (lambda ()
                                    (if (iterator_has_next inner_iter)
                                      (begin
                                        (set has_next TRUE)
                                        (set next
                                          (lambda ()
                                            (set has_next (lambda ()
                                                            (inner_find_next)
                                                            (has_next)))
                                            (set next     (lambda ()
                                                            (inner_find_next)
                                                            (next)))
                                            (iterator_next inner_iter))))
                                      (find_next))))]
                         (inner_find_next)))
                     (begin
                       (set has_next FALSE)
                       (set next BAD_NEXT))))),
               (has_next (lambda () (find_next) (has_next))),
               (next     (lambda () (find_next) (next)))]
        (make_iterator
          (lambda () (has_next))
          (lambda () (next))))))



  (defpub iterator_filter
    (lambda (proc iter)
      '''
Returns a lazy iterator that returns elements of ITER for which PROC returns
true when applied to the element.
      '''
      // TODO type-check proc
      (unless (is_iterator iter)
        (raise_argument_error "iterator_filter" "iterator" 1 proc iter))
      (letrec [(find_next
                 (lambda ()
                   (if (iterator_has_next iter)
                     (let [(v (iterator_next iter))]
                       (if (proc v)
                         (begin
                           (set has_next TRUE)
                           (set next
                             (lambda ()
                               (set has_next init_has_next)
                               (set next     init_next)
                               v)))
                         (find_next)))
                     (begin
                       (set has_next FALSE)
                       (set next BAD_NEXT))))),
               (init_has_next (lambda () (find_next) (has_next))),
               (init_next     (lambda () (find_next) (next))),
               (has_next init_has_next),
               (next     init_next)]
        (make_iterator
          (lambda () (has_next))
          (lambda () (next))))))


  (defpub iterator_append
    (lambda (iter1 iter2)
      '''
Returns an iterator that returns elements of ITER1 and then ITER2.
      '''
      (unless (is_iterator iter1)
        (raise_argument_error "iterator_append" "iterator" 0 iter1 iter2))
      (unless (is_iterator iter2)
        (raise_argument_error "iterator_append" "iterator" 1 iter1 iter2))
      (letrec [(find_next
                 (lambda ()
                   (if (iterator_has_next iter1)
                     (begin
                       (set has_next TRUE)
                       (set next
                         (lambda ()
                           (set has_next init_has_next)
                           (set next     init_next)
                           (iterator_next iter1))))
                     (begin
                       (set has_next (lambda () (iterator_has_next iter2)))
                       (set next     (lambda () (iterator_next     iter2))))))),
               (init_has_next (lambda () (find_next) (has_next))),
               (init_next     (lambda () (find_next) (next))),
               (has_next init_has_next),
               (next     init_next)]
        (make_iterator
          (lambda () (has_next))
          (lambda () (next))))))

  // Another way to append. This iterator takes less space but makes lots of
  // has_next calls. The above only calls it once per element.
  (define iterator_append_alternate
    (lambda (iter1 iter2)
      '''
Returns an iterator that returns elements of ITER1 and then ITER2.
      '''
      (unless (is_iterator iter1)
        (raise_argument_error "iterator_append" "iterator" 0 iter1 iter2))
      (unless (is_iterator iter2)
        (raise_argument_error "iterator_append" "iterator" 1 iter1 iter2))
      (make_iterator
        (lambda () (or (iterator_has_next iter1) (iterator_has_next iter2)))
        (lambda () (if (iterator_has_next iter1)
                     (iterator_next iter1)
                     (iterator_next iter2))))))


)

// Copyright (c) 2012 Amazon.com, Inc.  All rights reserved.

(module vector 'fusion/base'

  '''
Core operations for vectors (_a.k.a._ arrays).

A _vector_ is a sequence of values with zero-based integer keys and
constant-time lookup of elements.  Vectors come in three concrete types:
immutable, mutable, or stretchy; a stretchy vector IS-A mutable vector.
Non-stretchy vectors are comparable to Java arrays, while stretchy vectors are
comparable to `ArrayList`s; however, Fusion doesn't guarantee that the
elements of a vector are contiguous in memory.

## Creating Vectors

In standard Fusion, Ion list syntax denotes immutable vectors:
`[]` denotes an immutable vector of size zero, and `[{f:x}]` denotes an
immutable vector of size 1 holding a struct of size 1.  The value of a vector
literal is immutable even when some child values are evaluated at run-time.
Quoted forms are also immutable; in `(quote [x])` the vector's sole element is
the symbol `'x'`.

The procedure `immutable_vector` has the same effect as a list literal.  The
procedure `vector` creates mutable vectors, and `stretchy_vector` creates
stretchy vectors:

    $ [1, 2]
    [1, 2]
    $ (vector 1 2)
    [1, 2]
    $ (stretchy_vector 1 2 3)
    [1, 2, 3]

Note that the REPL uses a default "ionization strategy" that renders all
vectors as Ion lists, so the results _look_ similar even though the values have
different types.  This is the converse of the default "deionizaton" strategy
that reads Ion lists as vectors.  Eventually the application will be able to
control this strategy; these defaults are designed to allow a Fusion developer
to construct data in various combinations of mutability (*etc.*) and output it
as "normal" Ion data.

## Using Vectors

The procedure `vector_ref` returns an element from inside the vector:

    $ (vector_ref ["oompa", "loompa"] 1)
    "loompa"

The procedure `vector_set` replaces an element in a mutable (including
stretchy) vector:

    $ (define immutable [1])
    $ (vector_set immutable 0 "new value")
    // vector_set expects mutable vector as 1st argument, given [1]
    Other arguments were:
      0
      "new value"
    $ (define mutable (vector 1))
    $ mutable
    [1]
    $ (vector_set mutable 0 "new value")
    $ mutable
    ["new value"]
    $ (vector_ref mutable 0)
    "new value"

The procedure `vector_add` accepts any vector type and returns a vector of the
same type, with a value added to the end.  It does not mutate the input vector,
and the result doesn't share any structure other than the contained elements.

    $ (vector_add mutable "newer")
    ["new value", "newer"]
    $ mutable
    ["new value"]
    $ (define stretchy (stretchy_vector true (quote blue)))
    $ stretchy
    [true, blue]
    $ (vector_add stretchy "magoo")
    [true, blue, "magoo"]
    $ stretchy
    [true, blue]

The procedure `vector_add_m` is a mutating procedure that, like `vector_add`,
returns a vector of the same type with a value added to the end. However, when
possible it achieves this through mutation and/or structure sharing. This means
that when given a stretchy vector, it will mutate that vector and then return
it.

    $ (vector_add_m mutable {})
    ["new value", {}]
    $ mutable
    ["new value"]
    $ (vector_add_m stretchy {})
    [true, blue, {}]
    $ stretchy
    [true, blue, {}]

The semantics of `vector_add` and `vector_add_m` are described a bit oddly here
because the `add` and `add_m` operations will be applicable to other Fusion
container types and will be polymorphic of their own right.  The `'_m'`
suffix is Fusion's spelling of the traditional `'!'` suffix in Scheme
languages, highlighting potential mutation of an argument.
  '''

  (use 'fusion/experimental/defines')
  (use 'fusion/iterator')
  (use 'fusion/unsafe/vector')         // NOT exported!


  (defpub_j is_vector
    "com.amazon.fusion.FusionVector$IsVectorProc")
  (defpub_j is_immutable_vector
    "com.amazon.fusion.FusionVector$IsImmutableVectorProc")
  (defpub_j is_mutable_vector
    "com.amazon.fusion.FusionVector$IsMutableVectorProc")
  (defpub_j is_stretchy_vector
    "com.amazon.fusion.FusionVector$IsStretchyVectorProc")


  (defpub_j immutable_vector
    "com.amazon.fusion.FusionVector$ImmutableVectorProc")
  (defpub_j vector // mutable
    "com.amazon.fusion.FusionVector$VectorProc")
  (defpub_j stretchy_vector
    "com.amazon.fusion.FusionVector$StretchyVectorProc")


  (defpub vector_size
    (lambda (vector)
      '''
Returns the size of `vector`.
      '''
      (unless (is_vector vector)
        (raise_argument_error "vector_size" "vector" 0 vector))
      (unsafe_vector_size vector)))


  (defpub vector_ref
    (lambda (vector pos)
      '''
Returns the element of `vector` at (zero-based) position `pos`.
      '''
      (unless (is_vector vector)
        (raise_argument_error "vector_ref" "vector" 0 vector pos))
      (unless (is_int pos)
        (raise_argument_error "vector_ref" "int" 1 vector pos))
      (when (or (< pos 0) (<= (unsafe_vector_size vector) pos))
        (raise_argument_error "vector_ref" "valid position" 1 vector pos))
      (unsafe_vector_ref vector pos)))


  (defpub vector_set
    (lambda (vector pos value)
      '''
Changes the slot of a mutable `vector` at (zero-based) position `pos` so it
holds `value`.
      '''
      (unless (is_mutable_vector vector)
        (raise_argument_error "vector_set" "mutable vector" 0 vector pos value))
      (unless (is_int pos)
        (raise_argument_error "vector_set" "int" 1 vector pos value))
      (when (or (< pos 0) (<= (unsafe_vector_size vector) pos))
        (raise_argument_error "vector_set" "valid position" 1 vector pos value))
      (unsafe_vector_set vector pos value)))


  (defpub vector_add
    (lambda (vector value)
      '''
Returns a vector similar to `vector` with the `value` added to the end.  The
given vector is not mutated.
      '''
      (unless (is_vector vector)
        (raise_argument_error "vector_add" "vector" 0 vector value))
      (unsafe_vector_add vector value)))


  (defpub vector_add_m
    (lambda (vector value)
      '''
Returns a vector similar to `vector` with the `value` added to the end.  The
result may share structure with the vector, which may also be mutated.

In particular, when given a stretchy vector, the input is expanded to contain
the given value, and the result is the `vector` argument.
      '''
      (unless (is_vector vector)
        (raise_argument_error "vector_add_m" "vector" 0 vector value))
      (unsafe_vector_add_m vector value)))


  (defpub vector_iterate
    (lambda (vector)
      "Returns an iterator over the content of `vector`."
      (unless (is_vector vector)
        (raise_argument_error "vector_iterate" "vector" 0 vector))
      (unsafe_vector_iterate vector)))


  (defpub vector_from_iterator
    (lambda (iter)
      '''
Creates a stretchy vector with the contents of `iterator`, in the same order.
      '''
      (unless (is_iterator iter)
        (raise_argument_error "vector_from_iterator" "iterator" 0 iter))
      (let loop ((result (stretchy_vector)))
        (if (iterator_has_next iter)
          (loop (vector_add_m result (iterator_next iter)))
          result))))
)

// Copyright (c) 2012 Amazon.com, Inc.  All rights reserved.

(module base '/fusion/private/builtins'

  (use '/fusion/syntax')
  (use '/fusion/experimental/defines')


  // Pass-through bindings from #%kernel
  (provide begin define if lambda letrec module use)
  (provide is_bool is_int is_float is_decimal is_timestamp is_symbol
      is_string is_clob is_blob is_list is_sexp is_struct)
  // Note that there's no is_null type checker, since that's used to
  // check for *any* null value.


  // Pass-through bindings from builtins
  (provide assert for_list let let_values quote set)
  (provide . < = apply concatenate exit
    for_each_field is_null is_procedure not
    raise_argument_error raise_result_error
    to_int to_string)


  (use '/fusion/number')
  (provide + - * /)

  (use '/fusion/params')
  (provide make_parameter parameterize)

  (use '/fusion/void')
  (provide is_void void)


  //==========================================================================
  // Basic procedures

  (defpub >
    (lambda (a b)
      '''
Returns true if A is strictly greater than B.  Both arguments must be of the
same type, either int, decimal, or timestamp.
      '''
      (< b a)))

  (defpub <=
    (lambda (a b)
      '''
Returns true if A is less than or equal to B.  Both arguments must be of the
same type, either int, decimal, or timestamp.
      '''
      (not (< b a))))

  (defpub >=
    (lambda (a b)
      '''
Returns true if A is greater than or equal to B.  Both arguments must be of
the same type, either int, decimal, or timestamp.
      '''
      (not (< a b))))


  //==========================================================================
  // Control forms

  (defpub_syntax and  // WARNING: Doc syntax isn't supported yet.
    '''
    (and expr ...)

Evaluates the EXPRs from left to right, returning the first untruthy value
that results (and ignoring further expressions). If they all return truthy
values, the last one is returned.

The last EXPR is in tail position. Given no EXPRs, the result is true.
    '''
    (lambda (stx)
      // (and)          -->  true
      // (and A)        -->  A
      // (and A B ...)  -->  (let [(a A)] (if a (and B ...) a))

      (let [(size (syntax_size stx))]
        (if (= 1 size)
          (quote_syntax true)
          (if (= 2 size)
            (syntax_get stx 1)
            (let [(first (syntax_get    stx 1)),
                  (rest  (syntax_subseq stx 2))]
              (let [(inner (syntax_cons_q and rest))]
                (quasisyntax
                  (let ((a (unsyntax first)))
                    (if a (unsyntax inner) a))))))))))


  (defpub_syntax or  // WARNING: Doc syntax isn't supported yet.
    '''
    (or expr ...)

Evaluates the EXPRs from left to right, returning the first truthy value
that results (and ignoring further expressions). If they all return untruthy
values, the last one is returned.

The last EXPR is in tail position. Given no EXPRs, the result is false.
    '''
    (lambda (stx)

      // (or)          -->  false
      // (or A)        -->  A
      // (or A B ...)  -->  (let [(a A)] (if a a (and B ...)))

      (let [(size (syntax_size stx))]
        (if (= 1 size)
          (quote_syntax false)
          (if (= 2 size)
            (syntax_get stx 1)
            (let [(first (syntax_get    stx 1)),
                  (rest  (syntax_subseq stx 2))]
              (let [(inner (syntax_cons_q or rest))]
                (quasisyntax
                  (let ((a (unsyntax first)))
                    (if a a (unsyntax inner)))))))))))


  (defpub_syntax when  // WARNING: Doc syntax isn't supported yet.
    '''
    (when test body ...)

Evaluates the TEST, and if it is truthy, evaluates the BODY expressions left
to right. The last BODY is in tail position, and its result is the result of
the entire form.  If the body isn't evaluated, the result is void.
    '''
    (lambda (stx)

      // (when TEST BODY ...)  -->  (if TEST (begin BODY ...) (void))

      (if (= 1 (syntax_size stx))
        (wrong_syntax stx "expected condition")
        (let ((test (syntax_get    stx 1))
              (body (syntax_subseq stx 2)))
          (let ((begin_body (syntax_cons_q begin body)))
            (quasisyntax
              (if (unsyntax test)
                  (unsyntax begin_body)
                  (void))))))))

  (defpub_syntax unless  // WARNING: Doc syntax isn't supported yet.
    '''
    (unless test body ...)

Evaluates the TEST, and if it is _not_ truthy, evaluates the BODY expressions
left to right. The last BODY is in tail position, and its result is the result
of the entire form.  If the body isn't evaluated, the result is void.
    '''
    (lambda (stx)

      // (unless TEST BODY ...)  -->  (if TEST (void) (begin BODY ...))

      (if (= 1 (syntax_size stx))
        (wrong_syntax stx "expected condition")
        (let ((test (syntax_get    stx 1))
              (body (syntax_subseq stx 2)))
          (let ((begin_body (syntax_cons_q begin body)))
            (quasisyntax
              (if (unsyntax test)
                  (void)
                  (unsyntax begin_body))))))))


// TODO FUSION-36  Support internal definitions in body sequences.
// Shouldn't use begin since that doesn't delimit the new scope that's needed.

  (defpub_syntax cond  // WARNING: Doc syntax isn't supported yet.
    '''
    (cond (test body ...) ...)

Evaluates the TEST expressions left to right until one returns a truthy value,
then evaluates the corresponding BODY in tail position.
If no TEST is truthy, the result is void.
    '''
    (lambda (stx)
      (let ((size (syntax_size stx)))
        (if (= 1 size)               // (cond) with no clauses
          (quote_syntax (void))
          (let ((clause (syntax_get    stx 1))
                (tail   (syntax_subseq stx 2)))
            (when (> 1 (syntax_size clause))
              (wrong_syntax stx "cond: bad clause " clause))
            (let ((test (syntax_get    clause 0))
                  (body (syntax_subseq clause 1)))
              (let ((begin_body (syntax_cons_q begin body))
                    (cond_tail  (syntax_cons_q cond  tail)))
                (quasisyntax
                  (if (unsyntax test)
                      (unsyntax begin_body)
                      (unsyntax cond_tail))))))))))

)

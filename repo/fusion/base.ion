// Copyright (c) 2012 Amazon.com, Inc.  All rights reserved.

(module base 'fusion/private/builtins'

  (use 'fusion/syntax')
  (use 'fusion/experimental/defines')


  // Pass-through bindings from #%kernel
  (provide begin current_directory define
    if lambda letrec load module undef use)
  (provide is_bool is_int is_float is_decimal is_timestamp is_symbol
      is_string is_clob is_blob is_list is_sexp is_struct)
  // Note that there's no is_null type checker, since that's used to
  // check for *any* null value.


  // Pass-through bindings from builtins
  (provide assert for_list let quote set)
  (provide * + - . < = add apply concatenate contains display exit
    for_each_field help is_null is_undef make_sexp not
    raise_argument_error raise_result_error read remove
    size to_int to_string write)


  (use 'fusion/params')
  (provide make_parameter parameterize)

  (use 'fusion/void')
  (provide is_void void)


  //==========================================================================
  // Basic procedures

  (defpub >
    (lambda (a b) (< b a)))

  (defpub <=
    (lambda (a b) (not (< b a))))

  (defpub >=
    (lambda (a b) (not (< a b))))


  //==========================================================================
  // Control forms

  (defpub_syntax and
    (lambda (stx)
      '''
(and expr ...)

Evaluates the EXPRs from left to right, returning the first untruthy value
that results (and ignoring further expressions). If they all return truthy
values, the last one is returned.

The last EXPR is in tail position. Given no EXPRs, the result is true.
      '''

      // (and)          -->  true
      // (and A)        -->  A
      // (and A B ...)  -->  (let [(a A)] (if a (and B ...) a))

      (let [(size (syntax_size stx))]
        (if (= 1 size)
          (quote_syntax true)
          (if (= 2 size)
            (syntax_get stx 1)
            (let [(first (syntax_get    stx 1)),
                  (rest  (syntax_subseq stx 2))]
              (let [(inner (syntax_cons and rest))]
                (quasisyntax
                  (let ((a (unsyntax first)))
                    (if a (unsyntax inner) a))))))))))


  (defpub_syntax or
    (lambda (stx)
      '''
(or expr ...)

Evaluates the EXPRs from left to right, returning the first truthy value
that results (and ignoring further expressions). If they all return untruthy
values, the last one is returned.

The last EXPR is in tail position. Given no EXPRs, the result is false.
      '''

      // (or)          -->  false
      // (or A)        -->  A
      // (or A B ...)  -->  (let [(a A)] (if a a (and B ...)))

      (let [(size (syntax_size stx))]
        (if (= 1 size)
          (quote_syntax false)
          (if (= 2 size)
            (syntax_get stx 1)
            (let [(first (syntax_get    stx 1)),
                  (rest  (syntax_subseq stx 2))]
              (let [(inner (syntax_cons or rest))]
                (quasisyntax
                  (let ((a (unsyntax first)))
                    (if a a (unsyntax inner)))))))))))


  (defpub_syntax when
    (lambda (stx)

      // (when TEST BODY ...)  -->  (if TEST (begin BODY ...) (void))

      (if (= 1 (syntax_size stx))
        (wrong_syntax stx "expected condition")
        (let ((test (syntax_get    stx 1))
              (body (syntax_subseq stx 2)))
          (let ((begin_body (syntax_cons begin body)))
            (quasisyntax
              (if (unsyntax test)
                  (unsyntax begin_body)
                  (void))))))))

  (defpub_syntax unless
    (lambda (stx)

      // (unless TEST BODY ...)  -->  (if TEST (void) (begin BODY ...))

      (if (= 1 (syntax_size stx))
        (wrong_syntax stx "expected condition")
        (let ((test (syntax_get    stx 1))
              (body (syntax_subseq stx 2)))
          (let ((begin_body (syntax_cons begin body)))
            (quasisyntax
              (if (unsyntax test)
                  (void)
                  (unsyntax begin_body))))))))


// TODO FUSION-36  Support internal definitions in body sequences.
// Shouldn't use begin since that doesn't delimit the new scope that's needed.

  (defpub_syntax cond
    (lambda (stx)
      (let ((size (syntax_size stx)))
        (if (= 1 size)               // (cond) with no clauses
          (quote_syntax (void))
          (let ((clause (syntax_get    stx 1))
                (tail   (syntax_subseq stx 2)))
            (when (> 1 (syntax_size clause))
              (wrong_syntax stx "cond: bad clause " clause))
            (let ((test (syntax_get    clause 0))
                  (body (syntax_subseq clause 1)))
              (let ((begin_body (syntax_cons begin body))
                    (cond_tail  (syntax_cons cond  tail)))
                (quasisyntax
                  (if (unsyntax test)
                      (unsyntax begin_body)
                      (unsyntax cond_tail))))))))))

)

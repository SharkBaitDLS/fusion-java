// Copyright (c) 2012 Amazon.com, Inc.  All rights reserved.

(module base 'fusion/private/builtins'


  // Pass-through bindings from #%kernel
  (provide begin current_directory define eval_file
    if lambda letrec module undef use)
  (provide is_bool is_int is_float is_decimal is_timestamp is_symbol
      is_string is_clob is_blob is_list is_sexp is_struct)
  // Note that there's no is_null type checker, since that's used to
  // check for *any* null value.


  // Pass-through bindings from builtins
  (provide and assert for_list let or quote)
  (provide * + - . < = > add apply concatenate contains display exit
    for_each_field help is_null is_undef make_sexp not read remove
    size to_int to_string write)


  (use 'fusion/params')
  (provide make_parameter parameterize)



  (use 'fusion/syntax')

  (provide when)
  (define_syntax when
    (lambda (stx)

      // (when TEST BODY ...)  -->  (if TEST (begin BODY ...) undef)

      (if (= 1 (syntax_size stx))
        (wrong_syntax stx "expected condition")
        (let ((test (syntax_get    stx 1))
              (body (syntax_subseq stx 2)))
          (let ((begin_body (syntax_cons begin body)))
            (quasisyntax
              (if (unsyntax test)
                  (unsyntax begin_body)
                  undef)))))))

  (provide unless)
  (define_syntax unless
    (lambda (stx)

      // (unless TEST BODY ...)  -->  (if TEST undef (begin BODY ...))

      (if (= 1 (syntax_size stx))
        (wrong_syntax stx "expected condition")
        (let ((test (syntax_get    stx 1))
              (body (syntax_subseq stx 2)))
          (let ((begin_body (syntax_cons begin body)))
            (quasisyntax
              (if (unsyntax test)
                  undef
                  (unsyntax begin_body))))))))


// TODO FUSION-36  Support internal definitions in body sequences.
// Shouldn't use begin since that doesn't delimit the new scope that's needed.

  (provide cond)
  (define_syntax cond
    (lambda (stx)
      (let ((size (syntax_size stx)))
        (if (= 1 size)               // (cond) with no clauses
          (quote_syntax undef)
          (let ((clause (syntax_get    stx 1))
                (tail   (syntax_subseq stx 2)))
            (when (> 1 (syntax_size clause))
              (wrong_syntax stx "cond: bad clause " clause))
            (let ((test (syntax_get    clause 0))
                  (body (syntax_subseq clause 1)))
              (let ((begin_body (syntax_cons begin body))
                    (cond_tail  (syntax_cons cond  tail)))
                (quasisyntax
                  (if (unsyntax test)
                      (unsyntax begin_body)
                      (unsyntax cond_tail))))))))))

)

// Copyright (c) 2012-2013 Amazon.com, Inc.  All rights reserved.

(module base '/fusion/private/builtins'

  (require
    "/fusion/experimental/defines"
    "/fusion/syntax")


  // Pass-through bindings from kernel
  // TODO FUSION-133 remove `use`
  (provide all_defined_out begin define if lambda letrec module provide
    require use)
  (provide is_bool is_int is_float is_decimal is_timestamp is_symbol
      is_string is_clob is_blob is_list is_sexp is_struct)
  // Note that there's no is_null type checker, since that's used to
  // check for *any* null value.


  // Pass-through bindings from builtins
  (provide assert for_list let let_values quote set '#%top')
  (provide . apply exit is_null is_procedure not
    raise_argument_error raise_result_error
    to_int to_string)

  // TODO FUSION-95 these bindings seem out of place:
  //  assert for_list to_int to_string raise_*

  (require "/fusion/private/compare")
  (provide < <= = >= >)

  (require "/fusion/private/control")
  (provide and or when unless cond)

  (require "/fusion/number")
  (provide + - * /)

  (require "/fusion/void")
  (provide is_void void)


  //==========================================================================
  // Binding forms

/*
(lets [] body ...+)
=>
(begin body ...)

(lets [binding, others ...] body ...+)
=>
(let [binding]
  (lets [others ...]
    body ...))
*/

  (defpub_syntax lets
    '''
    (lets [(ident expr), ...] body ...+)

Like `let`, but each binding is created (and its `expr` evaluated) one by one,
and the `ident`s are bound in the following `expr`s as well as the `body`.

    (lets [(a 1),
           (b (+ a 1))]
      [a, b])            => [1, 2]
    '''
    (lambda (stx)
      (if (< (syntax_size stx) 3)
        (wrong_syntax stx "expecting bindings and body")
        (let [(bindings (syntax_get    stx 1)),
              (body     (syntax_subseq stx 2))]
          // TODO FUSION-120 check type of bindings, bound identifier
          (if (= 0 (syntax_size bindings))
              (syntax_cons_q begin body)
              (let [(binding (syntax_get    bindings 0)),
                    (others  (syntax_subseq bindings 1))]
                (quasisyntax
                  (let ((unsyntax binding))   // TODO FUSION-46 can't use [] here
                    (unsyntax
                      (syntax_append
                        (quasisyntax (lets (unsyntax others)))
                        body))))))))))

)

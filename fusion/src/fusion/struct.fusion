// Copyright (c) 2012-2013 Amazon.com, Inc.  All rights reserved.

(module struct '/fusion/base'

  '''
Operations for structs.

A _struct_ is an unordered [collection](fusion/collection.html) of values,
keyed by strings.  Since Fusion structs are based on Ion structs, these
collections are multi-maps: the same key can map to multiple values, or even
multiple mappings to the same value.

The _elements_ of a struct are its values, but not the associated field names.

At present, all structs are immutable.  Issue FUSION-93 covers mutable structs.


## Creating Structs

In standard Fusion, Ion struct syntax denotes immutable values, treating field
names as literals and field values as expressions.  Thus
`{}` denotes an immutable struct of size zero, and `{f:[x]}` denotes an
immutable struct of size 1 holding a list whose only element is the value of
the variable `x`.  The value of a struct
literal is immutable even when some child values are evaluated at run-time,
but elements of such a struct may be mutable.
Quoted forms are also immutable; in `(quote {f:x})` the struct's sole element
is the symbol `'x'`.

The procedure `struct` works like a struct literal, creating an immutable
struct from names and elements:

    (struct "name" "Steve" "age" 29)  =>  {name:"Steve", age:29}

`struct_zip` is similar, but accepts lists containing the names and
elements:

    (struct ["name", "age"] ["Doug", 38])  =>  {age:38, name:"Doug"}

The procedures `remove_keys` and `retain_keys` functionally eliminate fields
from a struct without modifying the input.  `struct_merge` combines the fields
from two structs.


## Iterating Struct Fields

The procedure `struct_for_each` iterates the name/value pairs within a struct,
but since the input isn't modified one must use side effects.

More general [collection](fusion/collection.html) operations like `any` and
`find` can be applied to structs, in which case the field names are ignored
while the field values are iterated.
  '''

  (require
    "/fusion/collection"
    "/fusion/exception"
    "/fusion/experimental/defines"
    "/fusion/ffi/java"
    "/fusion/private/builtins"   // unsafe_struct_visit
    "/fusion/private/struct")


  // Pass-through bindings from /fusion/private/kernel
  (provide is_struct)

  // Pass-through bindings from /fusion/collection
  (provide . any do element elt every find has_key is_empty size)

  (defpub_j struct          "com.amazon.fusion.FusionStruct$StructProc")
  (defpub_j mutable_struct  "com.amazon.fusion.FusionStruct$MutableStructProc")

  (defpub_j is_immutable_struct
    "com.amazon.fusion.FusionStruct$IsImmutableStructProc")
  (defpub_j is_mutable_struct
    "com.amazon.fusion.FusionStruct$IsMutableStructProc")

  (defpub_j remove_keys       "com.amazon.fusion.FusionStruct$RemoveKeysProc")
  (defpub_j remove_keys_m     "com.amazon.fusion.FusionStruct$RemoveKeysMProc")
  (defpub_j retain_keys       "com.amazon.fusion.FusionStruct$RetainKeysProc")
  (defpub_j retain_keys_m     "com.amazon.fusion.FusionStruct$RetainKeysMProc")
  (defpub_j struct_merge      "com.amazon.fusion.FusionStruct$StructMergeProc")
  (defpub_j struct_zip        "com.amazon.fusion.FusionStruct$StructZipProc")



  (defpub struct_set
    (lambda (struct key value)
      '''
Functionally adds a field to a `struct`, returning a new struct of the same
type. Any existing fields (including repeats) named by the `key` are replaced
by a single field with the `value`.

    (define s {a:1, b:2, b:3})

    (struct_set s "a" 4)    ==> {b:2,b:3,a:4}
    (struct_set s "b" 5)    ==> {b:5,a:1}
    (struct_set s "c" 6)    ==> {b:2,b:3,c:6,a:1}
    s                       ==> {b:2,b:3,a:1}
      '''
      (unless (is_struct struct)
        (raise_argument_error "struct_set" "struct" 0 struct key value))
      (unless (is_struct_field_name key)
        (raise_argument_error "struct_set" "field name" 1 struct key value))
      (unsafe_struct_set struct key value)))


  (defpub struct_set_m
    (lambda (struct key value)
      '''
Adds a field to a `struct`, mutating the `struct` when possible and returning
a struct of the same type. Any existing fields (including repeats) named by
the `key` are replaced by a single field with the `value`.

When given an immutable struct, `struct_set_m` behaves identically to
`struct_set`:

    (define s {a:1, b:2, b:3})

    (struct_set s "a" 4)    ==> {b:2,b:3,a:4}
    (struct_set s "b" 5)    ==> {b:5,a:1}
    (struct_set s "c" 6)    ==> {b:2,b:3,c:6,a:1}
    s                       ==> {b:2,b:3,a:1}

When given a mutable struct, the struct is mutated:

    (define s (mutable_struct "a" 1 "b" 2 "b" 3))

    s                       ==> {b:2,b:3,a:1}
    (struct_set_m s "a" 4)  ==> {b:2,b:3,a:4}
    (struct_set_m s "b" 5)  ==> {b:5,a:4}
    (struct_set_m s "c" 6)  ==> {b:5,c:6,a:4}
    s                       ==> {b:5,c:6,a:4}
      '''
      (unless (is_struct struct)
        (raise_argument_error "struct_set_m" "struct" 0 struct key value))
      (unless (is_struct_field_name key)
        (raise_argument_error "struct_set_m" "field name" 1 struct key value))
      (unsafe_struct_set_m struct key value)))


  // Name per Racket, where for-each is for side effects.
  (defpub struct_for_each
    (lambda (proc struct)
      '''
Iterates the fields of `struct` for side-effects, applying `proc` to each
name/value field.  Returns `struct`.  The `proc` must accept two arguments, a
field name symbol and a value; any results from applying the procedure are
ignored.
      '''
      // This is pretty much the same as struct_visit except we never return early.
      (unless (is_procedure proc)
        (raise_argument_error "struct_for_each" "procedure" 0 proc struct))
      (unless (is_struct struct)
        (raise_argument_error "struct_for_each" "struct" 1 proc struct))
      (unsafe_struct_visit
        (lambda (name elt) (proc name elt) false)
        struct)))

)

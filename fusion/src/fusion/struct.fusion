// Copyright (c) 2012-2013 Amazon.com, Inc.  All rights reserved.

(module struct '/fusion/base'

  '''
Operations for structs.

A _struct_ is an unordered [collection](fusion/collection.html) of values,
keyed by strings.  Since Fusion structs are based on Ion structs, these
collections are multi-maps: the same key can map to multiple values, or even
multiple mappings to the same value. The _elements_ of a struct are its values,
but not the associated field names.

Structs come in two concrete types: immutable and mutable. The procedures
`is_immutable_struct` and `is_mutable_struct` distinguish between them.

## Creating Structs

In standard Fusion, Ion struct syntax denotes immutable values, treating field
names as literals and field values as expressions.  Thus
`{}` denotes an immutable struct of size zero, and `{f:[x]}` denotes an
immutable struct of size 1 holding a list whose only element is the value of
the variable `x`.  The value of a struct
literal is immutable even when some child values are evaluated at run-time,
but elements of such a struct may be mutable.
Quoted forms are also immutable; in `(quote {f:x})` the struct's sole element
is the symbol `'x'`.

The procedure `struct` works like a struct literal, creating an immutable
struct from names and elements:

    (struct "name" "Steve" "age" 29)  =>  {name:"Steve", age:29}

The procedure `mutable_struct` similarly creates mutable structs:

    (mutable_struct "name" "Taylor" "age" 17)  =>  {name:"Taylor", age:17}

Note that the default "ionization strategy" renders all struct types the same,
so the results _look_ similar even though the values have different types.
Eventually the application will be able to control this strategy; these
defaults are designed to allow a Fusion developer to construct data in various
combinations of mutability (*etc.*) and output it as "normal" Ion data.

`struct_zip` is another way to create an immutable struct. It accepts lists
containing the names and elements:

    (struct_zip ["name", "age"] ["Doug", 38])  =>  {age:38, name:"Doug"}


## Modifying Structs

Fusion provides data modification operators that have a functional style, even
when the modification involves mutation. The functional and mutating variants
have the same signature and operate over both immutable and mutable types; in
general they are interchangable when used in a functional style.

Changing the key-value mappings of a struct is performed via `struct_set` and
`struct_set_m`, which guarantee that the result has only a single mapping for
the key:

    (struct_set {a:1, b:9, b:12} "b" 11)  => {a:1, b:11}

The procedures `remove_keys` and `retain_keys` functionally eliminate fields
from a struct without modifying the input; `remove_keys_m` and `retain_keys_m`
modify the input when possible.  `struct_merge` combines the fields
from two structs.


## Iterating Struct Fields

The procedure `struct_for_each` iterates the name/value pairs within a struct,
but since the input isn't modified one must use side effects.

More general [collection](fusion/collection.html) operations like `any` and
`find` can be applied to structs, in which case the field names are ignored
while the field values are iterated.
  '''

  (require
    "/fusion/collection"
    "/fusion/exception"
    "/fusion/experimental/defines"
    "/fusion/ffi/java"
    "/fusion/private/builtins"   // unsafe_struct_visit
    "/fusion/private/struct")


  // Pass-through bindings from /fusion/private/kernel
  (provide is_struct)

  // Pass-through bindings from /fusion/collection
  (provide . any do element elt every find has_key is_empty size)

  (defpub_j struct          "com.amazon.fusion.FusionStruct$StructProc")
  (defpub_j mutable_struct  "com.amazon.fusion.FusionStruct$MutableStructProc")

  (defpub_j is_immutable_struct
    "com.amazon.fusion.FusionStruct$IsImmutableStructProc")
  (defpub_j is_mutable_struct
    "com.amazon.fusion.FusionStruct$IsMutableStructProc")

  (defpub_j remove_keys       "com.amazon.fusion.FusionStruct$RemoveKeysProc")
  (defpub_j remove_keys_m     "com.amazon.fusion.FusionStruct$RemoveKeysMProc")
  (defpub_j retain_keys       "com.amazon.fusion.FusionStruct$RetainKeysProc")
  (defpub_j retain_keys_m     "com.amazon.fusion.FusionStruct$RetainKeysMProc")
  (defpub_j struct_merge      "com.amazon.fusion.FusionStruct$StructMergeProc")
  (defpub_j struct_zip        "com.amazon.fusion.FusionStruct$StructZipProc")



  (defpub struct_set
    (lambda (struct key value)
      '''
Functionally adds a field to a `struct`, returning a new struct of the same
type. Any existing fields (including repeats) named by the `key` are replaced
by a single field with the `value`.

    (define s {a:1, b:2, b:3})

    (struct_set s "a" 4)    ==> {b:2,b:3,a:4}
    (struct_set s "b" 5)    ==> {b:5,a:1}
    (struct_set s "c" 6)    ==> {b:2,b:3,c:6,a:1}
    s                       ==> {b:2,b:3,a:1}
      '''
      (unless (is_struct struct)
        (raise_argument_error "struct_set" "struct" 0 struct key value))
      (unless (is_struct_field_name key)
        (raise_argument_error "struct_set" "field name" 1 struct key value))
      (unsafe_struct_set struct key value)))


  (defpub struct_set_m
    (lambda (struct key value)
      '''
Adds a field to a `struct`, mutating the `struct` when possible and returning
a struct of the same type. Any existing fields (including repeats) named by
the `key` are replaced by a single field with the `value`.

When given an immutable struct, `struct_set_m` behaves identically to
`struct_set`:

    (define s {a:1, b:2, b:3})

    (struct_set s "a" 4)    ==> {b:2,b:3,a:4}
    (struct_set s "b" 5)    ==> {b:5,a:1}
    (struct_set s "c" 6)    ==> {b:2,b:3,c:6,a:1}
    s                       ==> {b:2,b:3,a:1}

When given a mutable struct, the struct is mutated:

    (define s (mutable_struct "a" 1 "b" 2 "b" 3))

    s                       ==> {b:2,b:3,a:1}
    (struct_set_m s "a" 4)  ==> {b:2,b:3,a:4}
    (struct_set_m s "b" 5)  ==> {b:5,a:4}
    (struct_set_m s "c" 6)  ==> {b:5,c:6,a:4}
    s                       ==> {b:5,c:6,a:4}
      '''
      (unless (is_struct struct)
        (raise_argument_error "struct_set_m" "struct" 0 struct key value))
      (unless (is_struct_field_name key)
        (raise_argument_error "struct_set_m" "field name" 1 struct key value))
      (unsafe_struct_set_m struct key value)))


  // Name per Racket, where for-each is for side effects.
  (defpub struct_for_each
    (lambda (proc struct)
      '''
Iterates the fields of `struct` for side-effects, applying `proc` to each
name/value field.  Returns `struct`.  The `proc` must accept two arguments, a
field name symbol and a value; any results from applying the procedure are
ignored.
      '''
      // This is pretty much the same as struct_visit except we never return early.
      (unless (is_procedure proc)
        (raise_argument_error "struct_for_each" "procedure" 0 proc struct))
      (unless (is_struct struct)
        (raise_argument_error "struct_for_each" "struct" 1 proc struct))
      (unsafe_struct_visit
        (lambda (name elt) (proc name elt) false)
        struct)))

)

// Copyright (c) 2013-2014 Amazon.com, Inc.  All rights reserved.

(module for '/fusion/private/kernel'

  '''
Generic collection "comprehension" forms.
  '''


  (require "/fusion/base"
           "/fusion/exception"
           "/fusion/experimental/defines"
           "/fusion/experimental/syntax"
           "/fusion/iterator"
           "/fusion/list"
           "/fusion/private/bind"
           "/fusion/sexp"
           "/fusion/unsafe/list"
           "/fusion/unsafe/sexp")


  (define ctx  // PRIVATE!
    "Lexical context for expanded macros."
    (quote_syntax context))


  (define (iterate series)
    (cond
      ((is_iterator series) series)
      ((is_list     series) (unsafe_list_iterator series))
      ((is_sexp     series) (unsafe_sexp_iterator series))
      (true (raise_result_error "for_list" "series" series))))


'''
(for_list [     ] BODY)  =>  (stretchy_list (begin BODY))


// TODO do we allocate new bindings for each I for each iteration?

(for_list [(I S) ...] BODY)
  =>
(let [(iters (map iterate (list S ...)),
      (result (stretchy_list))]
  (let loop []
    (if (all iterator_has_next iters)
      (let [(I (iterator_next (element iters 0))),
            ...]
        (add_m result (begin BODY))
        loop)
      result)))

'''

  // TODO FUSION-36 Should allow internal definitions
  // TODO Optimize for single-series case.
  //      That will make fors_list much more efficient.
  (defpub_syntax for_list
    '''
    (for_list ((id series) ...) body ...+)

Iterates the `series` in parallel, binding the corresponding `id`s to each
element in turn and evaluating `body`.  Each `series` expression must evaluate
to a list, sexp, or iterator.  Returns a stretchy list of the results.

If there are no `id`s declared, then the body is executed once.

    (for_list
      [ (even [0, 2, 4]),
        (odd  [1, 3, 5]) ]
      (+ even odd))             =>  [1, 5, 9]
    '''
    (lambda (stx)
      (let [(content (unsafe_pair_tail (syntax_unwrap stx)))]
        (when (< (size content) 2)
          (wrong_syntax stx "expecting bindings and body"))
        (let_values [((bindings body) (split_content stx content))]
          (let [(body (pair (quote_syntax begin) body)),
                (iters_id (quote_syntax iters))]
            (if (== 0 (size bindings))
              /* Base case -- no bindings */
              (datum_to_syntax
                (sexp (quote_syntax stretchy_list)   // (stretchy_list
                      body)                          //   (begin BODY...))
                ctx
                stx)
              (let_values [((ids series) (unzip_bindings stx bindings))]
                (let
                  [(ident_rebinds
                    (let loop [(rebinds (sexp)),
                               (ids ids),
                               (i 0)]
                      (if (is_empty ids)
                        rebinds
                        (loop (pair (sexp (head ids)
                                      (sexp (quote iterator_next)
                                        (sexp (quote element) iters_id i)))
                                    rebinds)
                              (tail ids)
                              (+ 1 i)))))]
                  (datum_to_syntax
                    (sexp
                      (quote let)
                      (quasisyntax
                        [((unsyntax iters_id)
                          (map iterate (unsyntax
                                         (datum_to_syntax
                                            (pair (quote list) series)
                                            ctx)))),
                         (result (stretchy_list))])
                      (quasisyntax
                        (let loop []
                          (if (every iterator_has_next (unsyntax iters_id))
                            (let (unsyntax (datum_to_syntax ident_rebinds ctx))
                              (add_m result (unsyntax (datum_to_syntax body ctx)))
                              (loop))
                            result))))
                    ctx
                    stx)))))))))



  (defpub_syntax fors_list
    '''
    (fors_list [(ident series), ...] body ...+)

Like `for_list`, but the `series` are iterated in nested loops instead of in parallel.
Each binding is made available to the following `series` as well as the `body` allowing
for list comprehension.

    (fors_list [(a [1,2]),
                (b [5,7])]
      (* a b))                             => [5, 7, 10, 14]

    (define data [{a:[ {b:1}, {b:2} ]},
                  {a:[ {b:3}, {b:4} ]} ])
    (fors_list [(x data),
                (y (. x "a"))]
      (. y "b"))                           => [1, 2, 3, 4]

    (define data [[[1],[2]],[[3],[4]]])
    (fors_list [(x data),
                (y x),
                (z y)]
      z)                                   => [1, 2, 3, 4]
    '''
    (lambda (stx)
      (let [(content (unsafe_pair_tail (syntax_unwrap stx)))]
        (when (< (size content) 2)
          (wrong_syntax stx "expecting bindings and body"))
        (let [(bindings (syntax_unwrap (unsafe_pair_head content))),
              (body (unsafe_pair_tail content))]
          (unless (and (is_sequence bindings) (not (is_null bindings)))
            (wrong_syntax stx "bindings must be a non-null sequence"))
          (if (== 0 (size bindings))
            /* Base case -- no bindings */
            (datum_to_syntax
              (pair (quote_syntax for_list)   // (for_list
                    (pair []                  //    []
                          body))              //    BODY...)
              ctx
              stx)
            (let [(binding (syntax_unwrap (element bindings 0))),
                  (others  (subseq bindings 1 (size bindings)))]
              (when (or (not (is_sequence binding))
                        (not (= 2 (size binding))))
                (wrong_syntax stx "expecting 2 forms in in each binding pair"))
              (if (== 0 (size others))
                /* Base case -- single binding */
                (datum_to_syntax
                  (pair (quote_syntax for_list)   // (for_list
                        (pair bindings            //    BINDINGS
                              body))              //    BODY...)
                  ctx
                  stx)
                /* Recursive case */
                (datum_to_syntax
                  (sexp (quote_syntax apply)         // (apply
                    (quote_syntax append_m)          //   append_m
                    []                               //   []
                    (sexp (quote_syntax for_list)    //   (for_list
                      (sexp (element bindings 0))    //     (BINDING)
                      (pair (quote_syntax fors_list) //     (fors_list
                        (pair others                 //       (OTHERS...)
                              body))))               //       BODY...)))
                  ctx
                  stx))))))))
)

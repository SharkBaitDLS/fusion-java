// Copyright (c) 2013-2018 Amazon.com, Inc.  All rights reserved.

(module exception '/fusion/private/kernel'

  '''
Operations for working with exceptions.

At present, Fusion has no support for catching exceptions or for creating
custom exception types.
  '''

  (require
    "/fusion/equality"
    "/fusion/experimental/syntax"
    "/fusion/ffi/java"
    "/fusion/private/bind"
    "/fusion/private/builtins"
    "/fusion/private/compare"
    "/fusion/private/control"
    "/fusion/private/kernel2"
    "/fusion/private/raise"
    "/fusion/private/sexp"
  )

  (provide // from /fusion/private/raise
    assert
    raise
    raise_argument_error
    raise_arity_error
    raise_contract_error
    raise_result_error
  )


  (provide call_with_handler)
  (define call_with_handler
    '''
    (call_with_handler handler thunk)

Installs the `handler` then calls the `thunk`.  If `raise` is called while
the thunk is evaluated, the handler is called with the raised value.
This happens in tail position with respect to `call_with_handler`.

The handler must be a procedure that accepts one argument: the raised value.

Most code should use the `with_handlers` syntax form instead of this procedure,
which is prone to error by using a non-thunk body expression.
    '''
    (java_new "com.amazon.fusion.CallWithHandlerProc"))

 (define (sequence_handler preds_and_handlers)  // Argument is a sexp of pairs.
   (lambda (raised)
     (let loop [(phs preds_and_handlers)]
       (if (not (is_pair phs))
         (raise raised)            // Re-raise the same exception.
         (let [(ph (head phs))]
           (if ((head ph) raised)
             ((tail ph) raised)
             (loop (tail phs))))))))


  (provide with_handlers)
  (define_syntax with_handlers
    '''
    (with_handlers ((pred_expr handler_expr) ...) body ...+)

Evaluates each `pred_expr` (predicate) and `handler_expr` (handler) in order,
and then the `body` forms.  The predicate and handler expressions must each
return a procedure that accepts one argument: a raised exception value.

If no exceptions are raised during evaluation of the body, then the result of
the `with_handlers` form is the result of the last `body` form.

If an exception is raised, then each predicate is applied to the exception
value. Once a predicate returns a truthy value, then the corresponding handler
is applied to the same value, and the handler's result becomes the result of
the entire `with_handlers` form. If the exception is not matched by any
predicate, then it is re-raised to the continuation of the `with_handlers`
expression.

Note, one should avoid using `(lambda (x) true)` as a condition because it
could potentially catch Errors, see the
[Racket Guide on Exceptions](https://docs.racket-lang.org/guide/exns.html) for more.
    '''
    (let [(ctx (quote_syntax here)),
          (wrong
            (lambda (stx)
              (wrong_syntax stx
                ''' Bad syntax for with_handlers; usage: '''
                ''' (with_handlers ((pred-expr handler-expr) ...) body ...+) ''')))]
      (lambda (stx)
        (if (< (syntax_size stx) 3)
          (wrong stx)
          null)
        (lets
          [(orig_args (tail (syntax_unwrap stx))),
           (body (tail orig_args)),
           (handler_args (let [(h (syntax_unwrap (head orig_args)))]
                           (if (is_sexp h) h
                             (if (is_list h) (apply sexp h)
                               (wrong stx))))),
           (ph_exprs
             (let loop [(phs handler_args)]
               (if (not (is_pair phs))
                 (quote ())
                 (let [(ph (head phs))]
                   (if (=== 2 (syntax_size ph))
                     (pair (sexp (quote_syntax pair) (syntax_get ph 0) (syntax_get ph 1))
                       (loop (tail phs)))
                     (wrong_syntax ph
                       '''Bad syntax. Handler must be a pair of predicate and handler expressions.'''))
                   ))))
          ]
          (datum_to_syntax
            (sexp (quote_syntax call_with_handler)         // (call_with_handler
              (sexp (quote_syntax sequence_handler)        //   (sequence_handler
                (pair (quote_syntax sexp) ph_exprs))       //     (sexp (pair P H) ...))
              (apply sexp (quote_syntax lambda) (quote ()) //   (lambda ()
                  body))                                   //     body ...+))
            ctx
            stx)))))


  (define FusionExn     (java_class "com.amazon.fusion.FusionException"))
  (define FusionUserExn (java_class "com.amazon.fusion.FusionUserException"))

  (provide is_exn)
  (define (is_exn v)
    '''
Determines whether a value is a Fusion exception.
    '''
    // This is special-case because we have to filter out non-exception values
    // that may have been raised.
    (and   (java_instance_of FusionExn     v)
      (not (java_instance_of FusionUserExn v))))


  (define_syntax generate_predicate
    (let [(ctx (quote_syntax here)),
          (docs "A predicate for use with `with_handlers`. Does NOT work outside of a `with_handlers` form.")]
      (lambda (stx)
        (lets
          [(orig_args (syntax_subseq stx 1)),
           (pred_name (syntax_get orig_args 0)),
           (exn_class (syntax_get orig_args 1)),]
          (datum_to_syntax
            (sexp (quote_syntax begin)                            // (begin
              (sexp (quote_syntax provide) pred_name)             //   (provide NAME)
              (sexp (quote_syntax define) pred_name               //   (define NAME
                docs                                              //     docs
                (quasisyntax
                  (let [(Exn (java_class (unsyntax exn_class)))]  //     (let [(Exn (java_class exn_class))]
                    (lambda (e)                                   //       (lambda (e)
                      (java_instance_of Exn e))))))               //         (java_instance_of Exn e)))))
            ctx
            stx)))))

  (generate_predicate is_argument_exn "com.amazon.fusion.ArgumentException")

  (generate_predicate is_arity_exn "com.amazon.fusion.ArityFailure")

  // TODO is_check_exn shouldn't be built-in.
  (generate_predicate is_check_exn "com.amazon.fusion.CheckException")

  (generate_predicate is_contract_exn "com.amazon.fusion.ContractException")

  (generate_predicate is_result_exn "com.amazon.fusion.ResultFailure")

  (generate_predicate is_syntax_exn "com.amazon.fusion.SyntaxException")

)

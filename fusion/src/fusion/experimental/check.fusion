// Copyright (c) 2012-2014 Amazon.com, Inc.  All rights reserved.

/*                       *** WARNING ***
 *
 * There are customer dependencies on this module!  See FUSION-333
 */

(module check "/fusion"

  '''
A lightweight unit testing library.

<!-- FUSION-185 This comment forces FusionDoc to stop the one-liner here. -->

## WARNING

This module contains unstable, experimental features.
There is **NO SUPPORT** for this module.
  '''


  (require
    "/fusion/eval"
    "/fusion/exception"
    "/fusion/experimental/defines"
    "/fusion/experimental/syntax"
    "/fusion/ffi/java"
    "/fusion/parameter")


  (define _raise_check_failure
    (java_new "com.amazon.fusion.CheckFailureProc"))

  (define check_stack_param
    (make_parameter null))

  // TODO Not public: the signature is awkward.
  (define fail_check
    '''
    (fail_check meta)

Raises a check failure exception, including a stack trace derived from the
`check_stack_param` marks.
    '''
    (lambda (meta)
      (parameterize [(check_stack_param meta)]
        (_raise_check_failure check_stack_param))))


  // TODO enable recursive checks?
  (defpub_syntax define_check
    (let [(ctx   (quote_syntax here)),
          (wrong (lambda (stx)
                   (wrong_syntax stx
                     '''Bad syntax for define_check; usage: '''
                     '''(define_check (name arg_name ...) body ...)''')))]
      (lambda (stx)
        '''
    (define_check (name arg ...) body ...)

Defines a new check form that's invoked as:

    (name arg_expr ... [message])

The body of the check can use other checks, but (at present) may not use
itself recursively.
        '''
        (when (< (syntax_size stx) 3)
          (wrong stx))
        (lets
          [(orig_args (tail (syntax_unwrap stx))),
           (signature (let [(s (syntax_unwrap (head orig_args)))]
                        (if (and (is_sexp s)
                                 (> (size s) 0)
                                 (every is_identifier s))
                            s
                            (wrong stx)))),
           (body      (tail orig_args)),
           (name_stx  (head signature)),
           // TODO check for duplicate arg names
           (args      (tail signature)),
           (arg_count (size args)),
           (arity_msg (string_append (syntax_unwrap name_stx)
                                     " requires at least "
                                     (int_to_string arg_count)
                                     (if (= 1 arg_count) " arg" " args")
                                     "; usage: ("
                                     (apply string_append
                                       (map (lambda (i)
                                              (string_append
                                                (syntax_unwrap i)
                                                " "))
                                          signature))
                                     "message ...)")),
           (proc_name (datum_to_syntax
                          (string_to_symbol
                            (string_append "_" (syntax_unwrap name_stx)))
                          // TODO FUSION-329 should use stx directly
                          (syntax_get stx 0)))]
          (datum_to_syntax
            (quasiquote
              (begin
                (define (unquote proc_name)
                  (lambda rest  // (meta ARG ... [message])
                    // Arity checking has happened in the calling check macro.
                    (let [(named_args (subseq rest
                                              1
                                              (unquote (+ 1 arg_count))))]
                      (parameterize
                        [(check_stack_param
                           (struct_merge (head rest)
                             (apply struct
                               "name" (quote (unquote name_stx))
                               "args" named_args
                               (if (> (size rest) (unquote (+ 1 arg_count)))
                                   (sexp "message" (last rest))
                                   (quote ())))))]
                        (apply (lambda (unquote args)
                                 (unquote (pair (quote begin) body)))
                          named_args)
                        // All checks should return void.
                        (void)))))
                (define_syntax (unquote name_stx)
                  (let [(ctx1 (quote_syntax here1))]
                    (lambda (stx1)
                      (let [(actuals (tail (syntax_unwrap stx1)))]
                        (when (or (< (size actuals) (unquote arg_count))
                                  (> (size actuals) (unquote (+ 1 arg_count))))
                          (wrong_syntax stx1 (unquote arity_msg)))
                        (let [(meta { expression: (syntax_to_datum stx1),
                                      line:       (syntax_line stx1),
                                      column:     (syntax_column stx1) })]
                          (datum_to_syntax
                            (pair (quote_syntax (unquote proc_name))
                                  (pair (sexp (quote quote) meta)
                                        actuals))
                            ctx1
                            stx1))))))))
            ctx
            stx)))))


  //===========================================================================


  (provide check)
  (define_check (check op val1 val2)
    (unless (op val1 val2)
      (fail_check {})))

  (provide check_pred)
  (define_check (check_pred pred val)
    (unless (pred val)
      (fail_check {})))

  (provide check_true)
  (define_check (check_true val)
    (unless (= true val)
      (fail_check {actual:val})))

  (provide check_false)
  (define_check (check_false val)
    (unless (= false val)
      (fail_check {actual:val})))

  (provide check_void)
  (define_check (check_void val)
    (unless (is_void val)
      (fail_check {actual:val})))


  (provide check_annotations)
  (define_check (check_annotations expected value)
    (unless (= expected (type_annotations value))
      (fail_check {expected:expected, actual:(type_annotations value)})))


  //===========================================================================


  (define thunk_throws
    (java_new "com.amazon.fusion.ThunkThrowsProc"))


  // TODO this should accept a predicate to check exn type
  (define_check (check_exn tag thunk)
    // TODO type-check thunk
    (let [(e (thunk_throws thunk))]
      (cond
        ((== e tag)
         (void))
        (e  (fail_check { expected: (string_append tag " exception"),
                          actual: (string_append e " exception")}))
        (true (fail_check { expected: (string_append tag " exception")})))))


  // This should really be a procedure, but it doesn't work.
  (define_syntax define_exn_check
    '''
    (define_exn_check name tag)

Defines a (public) check form used like `(name EXPR)`.
    '''
    (lambda (stx)
      (let [(ctx (quote_syntax here)),
            (name_stx (syntax_get stx 1)),
            (tag (syntax_unwrap (syntax_get stx 2)))]
        (datum_to_syntax
          (quasiquote
            (defpub_syntax (unquote name_stx)  // (name EXPR)
              (lambda (stx1)
                // TODO check arity
                (let [(ctx1 (quote_syntax here1)),
                      (thunk_stx (syntax_get stx1 1))]
                  (datum_to_syntax
                      // (check_exn tag (lambda () THUNK))
                    (sexp
                       (quote_syntax check_exn)
                       (unquote tag)
                       (sexp (quote_syntax lambda) (quote ())
                          thunk_stx))
                    ctx1
                    stx1)))))
          ctx
          stx))))


  (define_exn_check check_arg_exn      "arg")
  (define_exn_check check_arity_exn    "arity")
  (define_exn_check check_contract_exn "contract")
  (define_exn_check check_syntax_exn   "syntax")


  (defpub_syntax check_compile_exn
    '''
    (check_compile_exn top_form)
     ->
    (check_exn (lambda () (eval (quote top_form))))
    '''
    (lambda (stx)
      // TODO check arity
      (let [(top_form (syntax_get stx 1))]
        (quasisyntax
          (begin
            (check_syntax_exn
              (eval (quote_syntax (unsyntax top_form))))
            (check_syntax_exn
              (eval (quote (unsyntax top_form)))))))))
)

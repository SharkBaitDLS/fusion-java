// Copyright (c) 2012-2019 Amazon.com, Inc.  All rights reserved.

(require
  "/fusion/experimental/check"
  "/fusion/for"
  "/fusion/list"
  "/testutils")


(define iterate_values
  (lambda vs
    (iterator_map (|v| (apply values v))
      (sexp_iterator vs))))

(define_check (check_fl expected actual)
  (check_pred is_stretchy_list actual)
  (check === expected actual))

(check_fl [73]
  (for_list () 73))

(check_fl [84]
  (fors_list [] 84))

(check_fl []
  (for_list ((e [])) 73))
(check_fl []
  (for_list (((e) [])) 73))

(check_fl []
  (fors_list ((e [])) 84))
(check_fl []
  (fors_list (((e) [])) 84))

(check_fl [73]
  (for_list ((e [1])) 73))

(check_fl [84]
  (fors_list ((e [2])) 84))

(check_fl [1]
  (for_list ((e [1])) e))
(check_fl [1]
  (for_list (((e) [1])) e))

(check_fl [2]
  (fors_list ((e [2])) e))
(check_fl [2]
  (fors_list (((e) [2])) e))


// Multiple Series

(check_fl [11, 22, 33]
  (for_list ((e [1, 2, 3])
             (f [10, 20, 30]))
    (+ e f)))

(check_fl [11, 21, 31, 12, 22, 32, 13, 23, 33]
  (fors_list ((e [1, 2, 3])
              (f [10, 20, 30]))
    (+ e f)))


// Multivalue series

(check_fl [12, 34, 56]
  (for_list [((a b) (iterate_values [1, 2] [3, 4] [5, 6]))]
    (+ (* 10 a) b)))

(check_fl [125, 346]
  (for_list [((a b) (iterate_values [1, 2] [3, 4])),
             ((c)   (iterate_values [5] [6] [7]))]
    (+ (* 100 a) (* 10 b) c)))

(check_fl [1256, 3478]
  (for_list [((a b) (iterate_values [1, 2] [3, 4])),
             ((c d) (iterate_values [5, 6] [7, 8]))]
    (+ (* 1000 a) (* 100 b) (* 10 c) d)))

(check_fl [1256, 1278, 3456, 3478]
  (fors_list [((a b) (iterate_values [1, 2] [3, 4])),
              ((c d) (iterate_values [5, 6] [7, 8]))]
    (+ (* 1000 a) (* 100 b) (* 10 c) d)))


// Series of differing lengths

(check_fl [11, 22]
  (for_list ((e [1, 2, 3])
             (f [10, 20]))
    (+ e f)))

(check_fl [11, 21, 12, 22, 13, 23]
  (fors_list ((e [1, 2, 3])
              (f [10, 20]))
    (+ e f)))


// Mixed single/multi-identifier clauses

(check_fl [11, 22]
  (for_list (((e) [1, 2])
             (f   [10, 20]))
    (+ e f)))
(check_fl [11, 22]
  (for_list ((e   [1, 2])
             ((f) [10, 20]))
    (+ e f)))

(check_fl [11, 21, 12, 22]
  (fors_list (((e) [1, 2])
              (f   [10, 20]))
    (+ e f)))
(check_fl [11, 21, 12, 22]
  (fors_list ((e   [1, 2])
              ((f) [10, 20]))
    (+ e f)))


// Sexp works too
(check_fl [11, 22]
  (for_list ((e (quote (1 2)))
             (f [10, 20, 30]))
    (+ e f)))

(check_fl [11, 21, 31, 12, 22, 32]
  (fors_list ((e (quote (1 2)))
              (f [10, 20, 30]))
    (+ e f)))


// We can iterate structs.

(define_binary_check (check_bag expected actual)
  (bag_equal === expected actual))

(check_fl []
  (for_list [((k v) null.struct)] 1))

(check_bag (quote [(f 1), (g 2), (h 3)])
  (for_list [((k v) { f:1, g:2, h:3 })]
    (sexp k v)))


// Macro in bound-value position
(check_fl [74]
  (for_list ((e (let ((list [1])) list))) (+ e 73)))

(check_fl [85]
  (fors_list ((e (let ((list [1])) list))) (+ e 84)))

// Macro in body position
(check_fl [74]
  (for_list ((e [1])) (let ((v 73)) (+ e v))))

(check_fl [85]
  (fors_list ((e [1])) (let ((v 84)) (+ e v))))

// This tests two things:
//  1) non-Ion types in the result; here, closures.
//  2) use of new locations for the bound variables each iteration.
//     The thunks are applied after iteration completes, each one should have
//     its own location for variable `e`.
(check === [2, 4, 6]
  (map (lambda (thunk) (thunk))
    (for_list ((e [1, 2, 3]))
      (lambda () (* 2 e)))))

(check === [3, 6, 9]
  (map (lambda (thunk) (thunk))
    (fors_list ((e [1, 2, 3]))
      (lambda () (* 3 e)))))

// Check access to variables in surrounding scopes.
(lets [(data         [{ amountPosted:{ amount:-39.99 }},
                      { amountPosted:{ amount:-49.99 }} ]),
       (amountPosted "amountPosted"),
       (amount       "amount")]
  (check_fl [-39.99, -49.99]
    (for_list [(x data)]
      (. x  amountPosted   amount))))

(lets [(data         [{ amountsPosted:[ { amount:-39.99 }, { amount:-29.99 } ]},
                      { amountsPosted:[ { amount:-49.99 }, { amount:-59.99 } ]} ]),
       (amountsPosted "amountsPosted"),
       (amount        "amount")]
  (check_fl [-39.99, -29.99, -49.99, -59.99]
    (fors_list [(x data),
                (y (. x amountsPosted))]
      (. y amount))))


//  Evaluation order
(lets [(evaluation_order (stretchy_list)),
       (record (|v| (add_m evaluation_order v) v))]
  (check_fl [[1,2],[3,4]]
    (for_list [(a (begin (record "a") (iterator_map record (list_iterator [1, 3])))),
               (b (begin (record "b") (iterator_map record (list_iterator [2, 4]))))]
      [a,b]))
  (check === ["a", "b", 1, 2, 3, 4] evaluation_order))


(expect_syntax_exn (for_list))
(expect_syntax_exn (fors_list))
(expect_syntax_exn (for_list 1 2))
(expect_syntax_exn (fors_list 1 2 ))
(expect_syntax_exn (for_list null.sexp 13))
(expect_syntax_exn (fors_list null.sexp 24))
(expect_syntax_exn (for_list (12) 13))
(expect_syntax_exn (fors_list (23) 24))
(expect_syntax_exn (for_list (1 2) 13))
(expect_syntax_exn (fors_list (2 3) 24))
(expect_syntax_exn (for_list (()) 13))
(expect_syntax_exn (fors_list (()) 24))
(expect_syntax_exn (for_list ((12)) 13))
(expect_syntax_exn (fors_list ((23)) 24))
(expect_syntax_exn (for_list ((name)) 13))
(expect_syntax_exn (fors_list ((name)) 24))
(expect_syntax_exn (for_list ((name 1 2)) 13))
(expect_syntax_exn (fors_list ((name 2 3)) 24))
(expect_syntax_exn (for_list ((name 1) ()) 13))
(expect_syntax_exn (fors_list ((name 2) ()) 24))
(expect_syntax_exn (for_list ((name 1) (name2)) 13))
(expect_syntax_exn (fors_list ((name 2) (name3)) 24))
(expect_syntax_exn (for_list  ((name 1)) /* no body */))
(expect_syntax_exn (fors_list ((name 1)) /* no body */))

// Duplicate name
(expect_syntax_exn (for_list [(name []), (name [])] 13))


// Bad multi-bindings

(expect_syntax_exn (for_list [(null.sexp [])] 1))  // No ids
(expect_syntax_exn (for_list [(()        [])] 1))  // No ids
(expect_syntax_exn (for_list [((a 9)     [])] 1))  // Not an id
(expect_syntax_exn (for_list [([a, b]    [])] 1))  // Not a sexp

(expect_result_error
  (for_list [((a b) [1])] a))   // expects 2 values, returns 1
(expect_result_error
  (for_list [(k {f:1})] k))


// Duplicate fors_list binding names are allowed because they shadow
// each other in order, the last of which is still meaningful.
(check_fl []
  (fors_list [(name []), (name [])] 14))
(check_fl [3,4,3,4]
  (fors_list [(name [1,2]), (name [3,4])] name))

"PASSED" // Helpful output if you run this stand-alone

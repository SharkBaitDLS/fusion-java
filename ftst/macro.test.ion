// Copyright (c) 2012 Amazon.com, Inc.  All rights reserved.

(use 'fusion/syntax')
(use check)


// Very basic macro
(define_syntax S1
  (lambda (stx) (quote_syntax 99)))

(check_equal (S1) 99 "S1 macro expansion")


// Test use of macro as body of define_syntax
(define_syntax S2
  (let ((xform (lambda (stx) (quote_syntax 99))))
    xform))

(check_equal (S2) 99 "S2 macro expansion")


// (D v i) => (define i (lambda () v))
(define_syntax D
  (lambda (stx)
    (quasisyntax
      (define (unsyntax (syntax_get stx 2))
        (lambda () (unsyntax (syntax_get stx 1)))))))

(D 67 x)
(check_equal (x) 67 "D macro expansion")


//============================================================================
// syntax_append

(define_syntax join
  (lambda (stx)
    (syntax_append (syntax_get stx 1) (syntax_get stx 2))))

(check_equal (let ((x 3)) (join (+ 10 x) (x))) 16 "")


//============================================================================
// syntax_subseq

(define_syntax from1
  (lambda (stx)
    (syntax_subseq (syntax_get stx 1) 1)))

(check_equal (from1 (ignored + 2 3)) 5 "")

(define_syntax prepend_from1
  (lambda (stx)
    (syntax_append (quasisyntax (+ 1)) (syntax_subseq (syntax_get stx 1) 1))))

// Test syntax_subseq with index over size
(check_equal (prepend_from1 (2 3)) 4 "")
(check_equal (prepend_from1 (2  )) 1 "")
(check_equal (prepend_from1 (   )) 1 "")


//============================================================================

(define_syntax when2
  (lambda (when_stx)

    // Transforms:  (when C B ...)  -->  (if C (begin B ...) undef)

    (if (= 1 (syntax_size when_stx))
      (wrong_syntax when_stx "expected condition")
      (quasisyntax
        (if
          (unsyntax (syntax_get when_stx 1))
          (unsyntax (syntax_append (quasisyntax (begin))
                                   (syntax_subseq when_stx 2)))
          undef)))))


(check_equal (when2 true)       undef "when 0")
(check_equal (when2 true 1)     1 "when 1")
(check_equal (when2 true 1 2)   2 "when 2")
(check_equal (when2 true 1 2 3) 3 "when 3")
(check_equal (when2 false 1 2 3) undef "when false")


//============================================================================
// Hygiene tests

// Macro must not capture bindings from outside.

(define_syntax dont_capture
  (lambda (stx)
    (quasisyntax
      (let ((x 9))
        (unsyntax (syntax_get stx 1))))))

(check_equal (let ((x 3)) (dont_capture x)) 3 "macro capture")


// Macro use must not capture bindings from inside the macro.

(define_syntax or2 // 2-part or
  (lambda (stx)
    (let ((e1 (syntax_get stx 1))
          (e2 (syntax_get stx 2)))
      (quasisyntax
        (let ((t (unsyntax e1))) (if t t (unsyntax e2)))))))

(check_equal (let ((t true) (if false)) (or2 if t)) true "or2")


// Macro-defining macros require multiple syntax marks to maintain hygiene.

(define_syntax make_plus_N  // usage: (make_plus_N name n)
  (lambda (stx)
    (let ((name (syntax_get stx 1))
          (n    (syntax_get stx 2)))
      (quasisyntax
        (define_syntax (unsyntax name)  // usage: (name init)
          (lambda (stx)
            (let ((init (syntax_get stx 1)))
              (quasisyntax
                (let ((x (unsyntax init)))
                  (+ x (unsyntax (unsyntax n))))))))))))

(make_plus_N plus10 10)


"PASSED" // Helpful output if you run this stand-alone

// Copyright (c) 2012 Amazon.com, Inc.  All rights reserved.

(use check)
(use 'fusion/vector')


(define rester
  (lambda rest
    (assert (is_immutable_vector rest))
    rest))

(check_equal (rester)       []      "rest param 0")
(check_equal (rester 1)     [1]     "rest param 1")
(check_equal (rester 1 2 3) [1,2,3] "rest param 3")

(check_equal (apply rester [])         []        "apply rester 0")
(check_equal (apply rester [1])        [1]       "apply rester 1")
(check_equal (apply rester 1 2 [3, 4]) [1,2,3,4] "apply rester 4")


//==========================================================================
// set

(check_equal ((lambda (x) (set x (+ x 1)) x) 0) 1 "set1")

(define counter
  (let ((c 0))
    (lambda ()
      (set c (+ 1 c))
      c)))

(check_equal (counter) 1 "counter1")
(check_equal (counter) 2 "counter2")
(check_equal (counter) 3 "counter3")


//==========================================================================
// let_values
// TODO FUSION-84 test multiple return values

(check = (let_values [] 1) 1)

(check = (let_values [((x) 1)] x) 1)

(check =
  (let_values
    [((x) 1),
     ((y) 2)]
    (+ x y))
  3)


//==========================================================================
// letrec

(check_equal
  (letrec
    [(x y),
     (y 2)]
    x)
  undef "letrec undef'd binding")


//==========================================================================
// is_undef
//   ... tested here because undef should only come out of letrec

(check_equal (is_undef undef)  true  "is_undef undef")
// (check_equal (is_undef (void)) false "is_undef void") // TODO FUSION-71 FIXME
(check_equal (is_undef null)   false "is_undef null")
(check_equal (is_undef true)   false "is_undef true")
(check_equal (is_undef false)  false "is_undef false")
(check_equal (is_undef 0)      false "is_undef 0")
(check_equal (is_undef "")     false "is_undef \"\"")

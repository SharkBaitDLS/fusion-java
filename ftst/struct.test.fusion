// Copyright (c) 2012-2013 Amazon.com, Inc.  All rights reserved.

(require
  "/check"
  "/fusion/list"
  "/fusion/struct")


(define _struct_copy
  (lambda (ctor s)
    (if (is_null s)
      s
      (let [(args (stretchy_list))]
        (struct_for_each
          (lambda (name value)
            (add_m args name)
            (add_m args value))
          s)
        (apply ctor args)))))

(define struct_copy
  (lambda (s)
    (_struct_copy struct s)))

(define mutable_struct_copy
  (lambda (s)
    (_struct_copy mutable_struct s)))


(define (check_struct_mod op op_m fields args expect)
  '''
Checks a struct-modification operator of the form (op S args...) that returns
a struct. S is constructed twice by applying both `struct` and `mutable_struct`
to the `fields`, and the result of the operator must be the same type.
  '''
  (let [(s (apply struct fields))]
    (let [(result (apply op s args))]
      (check_pred is_immutable_struct result)
      (check ion_equals result expect
        "Unexpected result from " op " on immutable " s)
      (check ion_equals s (apply struct fields)               // s not mutated
        "Immutable struct was mutated by " op))
    (let [(result (apply op_m s args))]
      (check_pred is_immutable_struct result)
      (check ion_equals result expect
        "Unexpected result from " op_m " on immutable " s)
      (check ion_equals s (apply struct fields))))            // s not mutated
  (let [(s (apply mutable_struct fields))]
    (let [(result (apply op s args))]
      (check_pred is_mutable_struct result
        "result of " op " should be mutable")
      (check ion_equals result expect
        "Unexpected result from " op " on mutable " s)
      (check ion_equals s (apply struct fields)))             // s not mutated
    (let [(result (apply op_m s args))]
      (check_pred is_mutable_struct result)
      (check ion_equals result expect
        "Unexpected result from " op_m " on mutable " s)
      (check ion_equals s expect))))                          // s is mutated



(check_equal (. (quote {f:[]}) "f") [] "[] in quoted struct")

(check_equal (append_m (. {f:[]} "f") [1]) [1] "pulling list from struct")


(define test_predicates
  (lambda (struct expect_mutable expect_null expect_empty)
    (assert (is_struct struct))
    (check = (is_mutable_struct   struct)      expect_mutable )
    (check = (is_immutable_struct struct) (not expect_mutable))
    (check = (is_null  struct) expect_null)
    (check = (is_empty struct) expect_empty)
    // TODO ...
    ))


// Construction via literals

(test_predicates           null.struct  false true  true)
(test_predicates (quote    null.struct) false true  true)
(test_predicates (quote a::null.struct) false true  true)
(test_predicates           {}           false false true)
(test_predicates (quote    {})          false false true)
(test_predicates (quote a::{})          false false true)

(test_predicates (struct              ) false false true)
(test_predicates (struct "a" =        ) false false false)
(test_predicates (mutable_struct      ) true  false true)
(test_predicates (mutable_struct "a" =) true  false false)


(check_annotations (quote null.struct) (quote []))
(check_annotations (quote {}) (quote []))
(check_annotations (quote a::{}) (quote ["a"]))
(check_annotations (quote a::b::{}) (quote ["a","b"]))
(check_annotations (quote a::b::a::{}) (quote ["a","b","a"]))


//==========================================================================
// size

(check = (size null.struct) 0)


(define (test_size fields expect)
  (let [(s (apply struct fields))]
    (check = (size s) expect))
  (let [(s (apply mutable_struct fields))]
    (check = (size s) expect)))

(test_size (quote (       )) 0)
(test_size (quote (f 1    )) 1)
(test_size (quote (f 2 f 2)) 2)  // repeated field
(test_size (quote (f 2 g 2)) 2)


//==========================================================================
// has_key

(check_false (has_key null.struct ""))
(check_false (has_key null.struct null.string))
(check_false (has_key null.struct 2))


(define (test_has_key fields key expect)
  (let [(s (apply struct fields))]
    (check = (has_key s key) expect))
  (let [(s (apply mutable_struct fields))]
    (check = (has_key s key) expect)))

(test_has_key (quote ()) ""          false)
(test_has_key (quote ()) null.string false)
(test_has_key (quote ()) NULL_SYMBOL false)
(test_has_key (quote ()) 2           false)

(test_has_key (quote (a 1 b 2 c 3)) ""          false)
(test_has_key (quote (a 1 b 2 c 3)) null.string false)
(test_has_key (quote (a 1 b 2 c 3)) NULL_SYMBOL false)
(test_has_key (quote (a 1 b 2 c 3)) 2           false)
(test_has_key (quote (a 1 b 2 c 3)) "a"         true)
(test_has_key (quote (a 1 b 2 c 3)) (quote a)   true)

(test_has_key (quote (a null  )) "a"         true)
(test_has_key (quote (a false )) "a"         true)
(test_has_key (quote (a (void))) "a"         true)


(check_arity_exn (has_key))
(check_arity_exn (has_key {}))


//==========================================================================
// struct_set and struct_set_m

(check ion_equals (struct_set_m           null.struct  "f" 3)           {f:3})
(check ion_equals (struct_set_m (quote a::null.struct) "f" 3) (quote a::{f:3}))

(check ion_equals (struct_set_m           {}  "f" 3)           {f:3})
(check ion_equals (struct_set_m (quote a::{}) "f" 3) (quote a::{f:3}))


(define (test_set fields key value expect)
  (check_struct_mod struct_set struct_set_m fields (list key value) expect))

(test_set (quote (           )) "f" 3 {f:3})
(test_set (quote (a 1        )) "f" 3 {a:1,f:3})
(test_set (quote (a 1 a 2    )) "f" 3 {a:1,a:2,f:3})
(test_set (quote (a 1 b 2    )) "f" 3 {a:1,b:2,f:3})
(test_set (quote (a 1 f 2    )) "f" 3 {a:1,f:3})
(test_set (quote (a 1 f 2 f f)) "f" 3 {a:1,f:3})  // replace repeated field


(check_arity_exn (struct_set_m))
(check_arity_exn (struct_set_m {}))
(check_arity_exn (struct_set_m {} "f"))

(check_arg_exn (struct_set_m [] "f" 1))
(check_arg_exn (struct_set_m {} null.string 1))
(check_arg_exn (struct_set_m {} (quote null.symbol) 1))


//==========================================================================
// struct_merge and struct_merge_m

(do (lambda (case)
      (let [(arg1   (element case 0)),
            (arg2   (element case 1)),
            (expect (element case 2))]
        (check ion_equals (struct_merge   arg1 arg2) expect)
        (check ion_equals (struct_merge_m arg1 arg2) expect)))
  (quote
    [(a::null.struct  null.struct  a::null.struct),
     (a::null.struct  {}           a::null.struct),
     (a::null.struct  {a:1}        a::{a:1}      ),
     (a::null.struct  {a:1,b:2}    a::{a:1,b:2}  ),
     (a::null.struct  {a:1,a:3}    a::{a:1,a:3}  )]))


(define (check_merge fields other expect)
  (assert (is_immutable_struct other))
  (let [(other_m (mutable_struct_copy other))]
    (check_struct_mod struct_merge struct_merge_m fields (list other  ) expect)
    (check_struct_mod struct_merge struct_merge_m fields (list other_m) expect))
  (let [(s (apply mutable_struct fields)),
        (o (struct_copy other))]
    (let [(result (struct_merge s o))]
      (struct_set_m result "mod" "mod")
      (unless (= 0 (size o))
        (check_void (. s "mod")
          "Unexpected mutation of 1st arg in (struct_merge "
          (apply struct fields) " " other ")"))
      (check_void (. o "mod")
        "Unexpected mutation of 2nd arg in (struct_merge " s " " other ")"))
    (let [(result (struct_merge_m s o))]
      (struct_set_m result "mod" "mod")
      (check_void (. o "mod")
        "Unexpected mutation of 2nd arg in (struct_merge_m " s " " other ")"))))


(check_merge (sexp) null.struct       {})
(check_merge (sexp) {}                {})
(check_merge (sexp) {a:1}             {a:1})
(check_merge (sexp) {a:1,b:2}         {a:1,b:2})
(check_merge (sexp) {a:1,a:3}         {a:1,a:3})
(check_merge (sexp) {a:1,b:2,a:3,b:4} {a:1,b:2,a:3,b:4})

(check_merge (sexp "a" 0) null.struct       {a:0})
(check_merge (sexp "a" 0) {}                {a:0})
(check_merge (sexp "a" 0) {a:1}             {a:0,a:1})
(check_merge (sexp "a" 0) {a:1,b:2}         {a:0,a:1,b:2})
(check_merge (sexp "a" 0) {a:1,a:3}         {a:0,a:1,a:3})
(check_merge (sexp "a" 0) {a:1,b:2,a:3,b:4} {a:0,a:1,b:2,a:3,b:4})

(check_merge (sexp "a" 0 "b" 2) null.struct       {a:0,b:2})
(check_merge (sexp "a" 0 "b" 2) {}                {a:0,b:2})
(check_merge (sexp "a" 0 "b" 2) {a:1}             {a:0,b:2,a:1})
(check_merge (sexp "a" 0 "b" 2) {a:1,b:2}         {a:0,b:2,a:1,b:2})
(check_merge (sexp "a" 0 "b" 2) {a:1,a:3}         {a:0,b:2,a:1,a:3})
(check_merge (sexp "a" 0 "b" 2) {a:1,b:2,a:3,b:4} {a:0,b:2,a:1,b:2,a:3,b:4})

// TODO check annotations on inputs


//==========================================================================
// struct_merge1 and struct_merge1_m

(require "/fusion/experimental/struct")

(do (lambda (case)
      (let [(arg1   (element case 0)),
            (arg2   (element case 1)),
            (expect (element case 2))]
        (check ion_equals (struct_merge1   arg1 arg2) expect)
        (check ion_equals (struct_merge1_m arg1 arg2) expect)))
  (quote
    [(a::null.struct  null.struct  a::null.struct),
     (a::null.struct  {}           a::null.struct),
     (a::null.struct  {a:1}        a::{a:1}      ),
     (a::null.struct  {a:1,b:2}    a::{a:1,b:2}  ),
     (a::null.struct  {a:1,a:1}    a::{a:1}      )]))


(define (check_merge1 fields other expect)
  (assert (is_immutable_struct other))
  (let [(other_m (mutable_struct_copy other))]
    (check_struct_mod struct_merge1 struct_merge1_m fields (list other  ) expect)
    (check_struct_mod struct_merge1 struct_merge1_m fields (list other_m) expect))

  (let [(s (apply mutable_struct fields)),
        (o (struct_copy other))]
    (let [(result (struct_merge1 s o))]
      (struct_set_m result "mod" "mod")
      (unless (= 0 (size o))
        (check_void (. s "mod")
          "Unexpected mutation of 1st arg in (struct_merge1 "
          (apply struct fields) " " other ")"))
      (check_void (. o "mod")
        "Unexpected mutation of 2nd arg in (struct_merge1 " s " " other ")"))
    (let [(result (struct_merge1_m s o))]
      (struct_set_m result "mod" "mod")
      (check_void (. o "mod")
        "Unexpected mutation of 2nd arg in (struct_merge_m " s " " other ")"))))


(check_merge1 (sexp) null.struct       {})
(check_merge1 (sexp) {}                {})
(check_merge1 (sexp) {a:1}             {a:1})
(check_merge1 (sexp) {a:1,b:2}         {a:1,b:2})
(check_merge1 (sexp) {a:1,a:1}         {a:1})
(check_merge1 (sexp) {a:1,b:2,a:1,b:2} {a:1,b:2})

(check_merge1 (sexp "a" 0) null.struct       {a:0})
(check_merge1 (sexp "a" 0) {}                {a:0})
(check_merge1 (sexp "a" 0) {a:1}             {a:1})
(check_merge1 (sexp "a" 0) {a:1,b:2}         {a:1,b:2})
(check_merge1 (sexp "a" 0) {a:1,a:1}         {a:1})
(check_merge1 (sexp "a" 0) {a:1,b:2,a:1,b:2} {a:1,b:2})

(check_merge1 (sexp "a" 0 "b" 2) null.struct       {a:0,b:2})
(check_merge1 (sexp "a" 0 "b" 2) {}                {a:0,b:2})
(check_merge1 (sexp "a" 0 "b" 2) {a:1}             {a:1,b:2})
(check_merge1 (sexp "a" 0 "b" 2) {a:1,b:3}         {a:1,b:3})
(check_merge1 (sexp "a" 0 "b" 2) {a:1,a:1}         {a:1,b:2})
(check_merge1 (sexp "a" 0 "b" 2) {a:1,b:3,a:1,b:3} {a:1,b:3})

(check_merge1 (sexp "a" 0 "a" 0) null.struct       {a:0})
(check_merge1 (sexp "a" 0 "a" 0) {}                {a:0})
(check_merge1 (sexp "a" 0 "a" 0) {a:1}             {a:1})
(check_merge1 (sexp "a" 0 "a" 0) {a:1,b:3}         {a:1,b:3})
(check_merge1 (sexp "a" 0 "a" 0) {a:1,a:1}         {a:1})
(check_merge1 (sexp "a" 0 "a" 0) {a:1,b:3,a:1,b:3} {a:1,b:3})

// TODO check annotations on inputs


//==========================================================================
// struct_zip

(check ion_equals (struct_zip ["f"] [3]) {f:3})
(check ion_equals (struct_zip ["hello"] ["world"]) {hello:"world"})
(check ion_equals (struct_zip ["f","g"] [3,"hello"]) {f:3,g:"hello"})
(check ion_equals (struct_zip ["A","B"] [3,[true,false,[]]])
  {A:3,B:[true,false,[]]})

// Repeated fields
(check ion_equals (struct_zip ["A","A","A"] [2,1,3]) {A:1,A:2,A:3})

// Unequal lengths
(check ion_equals (struct_zip ["A","B"] [3]) {A:3})


//==========================================================================
// struct_for_each

(define rip_and_zip
  (lambda (struct)
    (let [(names  (stretchy_list)),
          (values (stretchy_list))]
      (let [(result (struct_for_each
                      (lambda (name value)
                        (add_m names name)
                        (add_m values value))
                      struct))]
        // TODO FUSION-88 (check eq result struct)
        (let [(zipped (struct_zip names values))]
          (check ion_equals zipped struct))))))

(rip_and_zip {})
(rip_and_zip {a:1,b:[2,3],c:{d:(quote e)}})
(rip_and_zip {a:1,b:[2,3],a:{d:(quote e)}})  // Repeated field

// TODO test struct_zip with null/empty string/symbol

// struct_for_each returns its input struct.
(check =
  (. (struct_for_each (lambda (k v) 3) {f:1}) "f")
  1)


//==========================================================================
// remove_keys and remove_keys_m

(check ion_equals (remove_keys null.struct) null.struct)
(check ion_equals (remove_keys null.struct "f") null.struct)


(define (test_remove_keys fields keys expect)
  (check_struct_mod remove_keys remove_keys_m fields keys expect))

(test_remove_keys (quote ()) [   ] {})
(test_remove_keys (quote ()) ["f"] {})

(test_remove_keys (quote (f 1    )) ["f"] {})
(test_remove_keys (quote (f 1 f 2)) ["f"] {})
(test_remove_keys (quote (f 1 f 2)) ["g"] {f:1,f:2})

(test_remove_keys (quote (g 2 f 1)) ["f", "h"      ] {g:2})
(test_remove_keys (quote (f 1 g 2)) ["f", (quote g)] {})


(check ion_equals (remove_keys (quote a::null.struct)) (quote a::null.struct))
(check ion_equals (remove_keys (quote a::{f:1}) "f") (quote a::{}))
(check ion_equals (remove_keys (quote a::{f:1}) "g") (quote a::{f:1}))
// TODO check annotations of mutable inputs


//==========================================================================
// retain_keys and retain_keys_m

(check ion_equals (retain_keys null.struct) null.struct)
(check ion_equals (retain_keys null.struct "f") null.struct)


(define (test_retain_keys fields keys expect)
  (check_struct_mod retain_keys retain_keys_m fields keys expect))

(test_retain_keys (quote ()) [   ] {})
(test_retain_keys (quote ()) ["f"] {})

(test_retain_keys (quote (f 1    )) ["g"] {})
(test_retain_keys (quote (f 1 f 2)) ["g"] {})
(test_retain_keys (quote (f 1 f 2)) ["f"] {f:1,f:2})
(test_retain_keys (quote (f 1 g 2)) ["f"] {f:1})
(test_retain_keys (quote (f 1 g 2)) ["h"] {})
(test_retain_keys (quote (f 1 g 2)) [   ] {})

(test_retain_keys (quote (a 1 b 3 c 2)) [   ] {})
(test_retain_keys (quote (a 1 b 3 c 2)) [(quote a), "c"] {a:1,c:2})


(check ion_equals (retain_keys (quote a::null.struct)) (quote a::null.struct))
(check ion_equals (retain_keys (quote a::{f:1}) "f") (quote a::{f:1}))
(check ion_equals (retain_keys (quote a::{f:1}) "g") (quote a::{}))
// TODO check annotations of mutable inputs


//==========================================================================
// any

(check_false (any T null.struct))
(check_false (any T {}))
(check_false (any F {f:1, g:2}))
(check_true  (any T {f:1, g:2}))

(check_true  (any (lambda (e) (= e "hi")) {f:"oh", g:"hi"}))
(check_false (any (lambda (e) (= e "ho")) {f:"oh", g:"hi"}))

(check =    (any (lambda (e) (when (= e "hi") e)) {f:"oh", g:"hi"}) "hi")

// Check that it returns the truthy predicate result, not the selected element
(check = 408
  (any (lambda (e) (when (= e 204) (* e 2)))
    {f:123, f:204, f:567}))
(check = 1134
  (any (lambda (e) (when (= e 567) (* e 2)))
    {f:123, f:204, f:567}))

// Check than it returns the last predicate result if none are truthy
(check_pred (conjoin is_null is_int)
  (any (lambda (s) null.int)
    {a:false, b:(void)}))
(check_pred is_null_null
  (any (lambda (s) null)
    {a:false, b:true}))
(check_void
  (any (lambda (s) (void))
    {a:false, b:null.int, c:null.list}))


//==========================================================================
// every

(check_true (every T null.struct))
(check_true (every T {}))
(check_false (every F {f:1, g:2}))
(check_true  (every T {f:1, g:2}))

(check_false (every (lambda (e) (= e "hi")) {f:"oh", g:"hi"}))
(check_true  (every (lambda (e) (= e "hi")) {f:"hi", g:"hi"}))

(check =    (every (lambda (e) (when (= e "hi") e)) {f:"hi", g:"hi"}) "hi")

// Check that it returns the untruthy predicate result
(check_void
  (every (lambda (e) (when (= e 204) e))
    {f:123, f:204, f:567}))
(check_pred is_null
  (every (lambda (e) (if (= e 123) e null))
    {f:123, f:456, f:678}))

// Check that `every` returns the last predicate result if all are truthy
(check = 1134
  (every (lambda (e) (when (or (= e 123) (= e 567)) (* e 2)))
    {f:123, g:123, h:567}))


//==========================================================================
// do

(check_equal (do (lambda (x) (+ 1 x)) {f:2, g:3})
   (void) "do returns void")

(let [(sum 0)]
  (do (lambda (x) (set sum (+ sum x))) {f:2, g:3})
  (check = sum 5))


//==========================================================================
// find

(assert (is_void (find F null.struct)))
(assert (is_void (find F {})))
(assert (is_void (find F {f:1, g:2})))
(check = (find T {f:1}) 1)

(check = (find (lambda (e) (= e "hi")) {f:"oh", g:"hi"}) "hi")

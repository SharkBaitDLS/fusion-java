// Copyright (c) 2013-2014 Amazon.com, Inc.  All rights reserved.

(require
  "/check"
  "/fusion/experimental/altlambda"
  "/fusion/experimental/compare"
  "/fusion/private/builtins"       // for `annotate`
  "/fusion/struct")


// Non-nulls are NOT = nulls

(do (|val|
      (unless (is_null val)
        (do (|nil|
              (check <> nil val)
              (check <> val nil))
          all_nulls)))
  representative_ion_data)


// Void is = to itself but nothing else

(define VOID (void))

(check = (void) (void))

(do (|val|
      (check <> VOID val)
      (check <> val VOID))
  representative_ion_data)


(define (add_annotations vals)
  (fold_left
    (|accum val|
      (if (is_void val)   // TODO need is_annotatable
        (pair val accum)
        (apply sexp
          val (annotate val "a") (annotate val "b") (annotate val "a" "c")
          accum)))
    (sexp)
    vals))

(define (test_pairwise op vals)
  (unless (is_empty vals)
    (let [(val1 (head vals))]
      (check op val1 val1)
      (do (|val2|
            (check op val1 val2)
            (check op val2 val1))
        (tail vals))
      (test_pairwise op (tail vals)))))

(define (test_equivalence equiv_sets)
  (let [(num_sets (size equiv_sets)),
        (equiv_sets (map add_annotations (apply list equiv_sets)))]
    // Create a list so we can index into it
    (do (|set| (test_pairwise = set)) equiv_sets)

    // Pick each set in the loop to compare its elements to the other sets
    (let set_loop [(i 0)]
      (when (< i num_sets)
        (do (|val1|
              (let other_set_loop [(j (+ 1 i))]
                (when (< j num_sets)
                  // Now we have a different equivalence set, all of its elts
                  // must be <> our chosen elt
                  (do (|val2|
                        (check <> val1 val2)
                        (check <> val2 val1))
                    (. equiv_sets j))
                  (other_set_loop (+ 1 j)))))
          (. equiv_sets i))
        (set_loop (+ 1 i))))))

(define '= equivs'
  '''
Sequence of equivalence sets.  Values shouldn't be annotated.
  '''
  (sexp
    // Each entry at this level is an equivalence set
    all_nulls
    (sexp VOID)
    (sexp true)
    (sexp false)
    (sexp "")
    (sexp "true")
    (sexp (quote 'true'))
    (sexp 1 1. 1.0 1.00)
    (sexp 0 0. -0. 0.00 -0.000)

    (sexp (pair 1 2) (pair 1.0 2.0))
    // These are similar to (but not =) 2-element sequences below:
    (sexp (pair null 1) (pair null.int 1.0))
    (sexp (pair 1 (quote null.sexp)) (pair 1.0 null.clob))

    (sexp [] (mutable_list) (stretchy_list)
      (quote ()) (sexp))
    (sexp [null] [null.int] (mutable_list null.bool) (stretchy_list null.list)
      (sexp null) (sexp null.int) (sexp (quote null.sexp)))
    // These are similar to (but not =) the pairs above:
    (sexp [null, 1] [null.int, 1.0] [(quote null.sexp), 1.00]
      (sexp null 1) (sexp null.int 1.0) (sexp (quote null.sexp) 1.00))
    (sexp [1] [1.0] [1.00]
      (sexp 1) (sexp 1.0) (sexp 1.00))
    // Note that the prior set is a prefix of this set.
    (sexp [1, true, [2.0]] [1.0, true, [2.00]] [1.00, true, [2.0]]
      (sexp 1 true [2.0]) (sexp 1.0 true [2.00]) (sexp 1.00 true [2.0]))

    (sexp {} (struct) (mutable_struct))
    (sexp {f:1} {f:1.0} {f:1.00})
    (sexp {f:1, g:2} {g:2.0, f:1.0} {f:1.00, g:2.00})
    (sexp {f:1, f:2} {f:1.0, f:2.0} {f:2, f:1.000})
    (sexp {f:1, g:9, f:2, f:2} {f:2, f:1.0, g:9, f:2.0}
      {g:9, f:2, f:1.000, f:2.00})
  ))

(test_equivalence '= equivs')

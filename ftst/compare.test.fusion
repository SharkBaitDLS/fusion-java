// Copyright (c) 2013-2014 Amazon.com, Inc.  All rights reserved.

(require
  "/check"
  "/fusion/experimental/altlambda"
  "/fusion/experimental/compare"
  "/fusion/list"
  "/fusion/private/builtins"       // for `annotate`
  "/fusion/struct")


// Non-nulls are NOT = nulls

(do (|val|
      (unless (is_null val)
        (do (|nil|
              (check <> nil val)
              (check <> val nil))
          all_nulls)))
  representative_ion_data)


// Void is = to itself but nothing else

(do (|val|
      (check <> VOID val)
      (check <> val VOID))
  representative_ion_data)


(define (add_annotations vals)
  (fold_left
    (|accum val|
      // TODO need is_annotatable
      (if (or (is_void val) (is_eof val) (is_identical val UNDEF))
        (pair val accum)
        (apply sexp
          val (annotate val "a") (annotate val "b") (annotate val "a" "c")
          accum)))
    (sexp)
    vals))

(define (test_pairwise op vals)
  (unless (is_empty vals)
    (let [(val1 (head vals))]
      (check op val1 val1)
      (do (|val2|
            (check op val1 val2)
            (check op val2 val1))
        (tail vals))
      (test_pairwise op (tail vals)))))

(define (test_equivalence eq neq equiv_sets)
  (let [(num_sets (size equiv_sets))]
    (do (|set| (test_pairwise eq set)) equiv_sets)

    // Pick each set in the loop to compare its elements to the other sets
    (let set_loop [(i 0)]
      (when (< i num_sets)
        (do (|val1|
              (let other_set_loop [(j (+ 1 i))]
                (when (< j num_sets)
                  // Now we have a different equivalence set, all of its elts
                  // must be <> our chosen elt
                  (do (|val2|
                        (check neq val1 val2)
                        (check neq val2 val1))
                    (. equiv_sets j))
                  (other_set_loop (+ 1 j)))))
          (. equiv_sets i))
        (set_loop (+ 1 i))))))

(test_equivalence = <>
  (map add_annotations
    (list
    // Each entry at this level is an equivalence set
    all_nulls
    (sexp VOID)
    (sexp UNDEF)
    (sexp eof)
    (sexp true)
    (sexp false)
    (sexp "")
    (sexp "true" (quote 'true'))
    (sexp 1 1. 1.0 1.00 10e-1)
    (sexp 0 0. -0. 0.00 -0.000 0e0 -0e0)
    (sexp 123 123. 123.0e0)
    (sexp 2014T
          2014-01T
          2014-01-01T
          2014-01-01T00:00Z
          2014-01-01T02:00+02:00)
    (sexp {{}} {{""}})
    (sexp {{Zm9vYmFy}} {{"foobar"}})
    (sexp (pair 1 2) (pair 1.0 2.0))
    // These are similar to (but not =) 2-element sequences below:
    (sexp (pair null 1) (pair null.int 1.0))
    (sexp (pair 1 NULL_SEXP) (pair 1.0 null.clob))

    (sexp [] (mutable_list) (stretchy_list)
      (quote ()) (sexp))
    (sexp [null] [null.int] (mutable_list null.bool) (stretchy_list null.list)
      (sexp null) (sexp null.int) (sexp NULL_SEXP))
    // These are similar to (but not =) the pairs above:
    (sexp [null, 1] [null.int, 1.0] [NULL_SEXP, 1.00]
      (sexp null 1) (sexp null.int 1.0) (sexp NULL_SEXP 1.00))
    (sexp [1] [1.0] [1.00]
      (sexp 1) (sexp 1.0) (sexp 1.00))
    // Note that the prior set is a prefix of this set.
    (sexp [1, true, [2.0]] [1.0, true, [2.00]] [1.00, true, [2.0]]
      (sexp 1 true [2.0]) (sexp 1.0 true [2.00]) (sexp 1.00 true [2.0]))

    (sexp {} (struct) (mutable_struct))
    (sexp {f:1} {f:1.0} {f:1.00})
    (sexp {f:1, g:2} {g:2.0, f:1.0} {f:1.00, g:2.00})
    (sexp {f:1, f:2} {f:1.0, f:2.0} {f:2, f:1.000})
    (sexp {f:1, g:9, f:2, f:2} {f:2, f:1.0, g:9, f:2.0}
      {g:9, f:2, f:1.000, f:2.00})
  )))

(define !== (|a b| (not (== a b))))

(test_equivalence == !==
  (map add_annotations
    (append_m
    // Nulls are their own equivalence sets
    (apply mutable_list (map sexp all_nulls))
    (list
      (sexp VOID)
      (sexp UNDEF)
      (sexp eof)
      (sexp true)
      (sexp false)
      (sexp "")
      (sexp "true")
      (sexp (quote 'true'))
      (sexp 1)
      (sexp 1. 1.0 1.00)
      (sexp 0)
      (sexp 0. -0. 0.00 -0.000)
      (sexp 0e0 -0e0 0.00e-1)
      (sexp 2014T
            2014-01T
            2014-01-01T
            2014-01-01T00:00Z
            2014-01-01T02:00+02:00)
      (sexp {{}})
      (sexp {{""}})
      (sexp {{Zm9vYmFy}})
      (sexp {{"foobar"}})
      (sexp (pair 1 2))
      (sexp (pair 1.0 2.0) (pair 1. 2.000))
      // These are similar to (but not ==) 2-element sequences below:
      (sexp (pair null 1))
      (sexp (pair null.int 1))

      (sexp [] (mutable_list) (stretchy_list))
      (sexp (quote ()) (sexp))
      (sexp [null])
      (sexp [null.int] (mutable_list null.int) (stretchy_list null.int))
      (sexp (sexp null))
      (sexp (sexp null.int))
      (sexp (sexp NULL_SEXP))
      (sexp [null, 1])
      (sexp [null.int, 1.0] [null.int, 1.])
      (sexp [NULL_SEXP, 1.00])
      (sexp (sexp null 1))
      (sexp (sexp null.int 1.0) (sexp null.int 1.0))
      (sexp [1])
      (sexp [1.0] [1.00])
      (sexp (sexp 1))
      (sexp (sexp 1.0) (sexp 1.00))
      (sexp [1 , true, [2.0]] [1  , true, [2.00]])
      (sexp [1., true, [2.0]] [1.0, true, [2.00]] [1.00, true, [2.0]])
      (sexp (sexp 1 true [2.0]) (sexp 1 true [2.00]) (sexp 1 true [2.0]))

      (sexp {} (struct) (mutable_struct))
      (sexp {f:1})
      (sexp {f:1.0} {f:1.00})
      (sexp {f:1, g:2})
      (sexp {g:2.0, f:1.0} {f:1.00, g:2.00})
      (sexp {f:1, f:2})
      (sexp {f:1.0, f:2.0})
      (sexp {f:2, f:1.000})
      (sexp {f:1., g:9, f:2, f:2} {f:2, f:1.0, g:9, f:2}
        {g:9, f:2, f:1.000, f:2})
    ))))


(define !=== (|a b| (not (=== a b))))

(test_equivalence === !===
  (apply list
    (fold_left
      (|accum eqSet|
        (let [(val (. eqSet 0))]
          // TODO need is_annotatable
          (if (or (is_void val) (is_eof val) (is_identical val UNDEF))
            (pair eqSet accum)
            (apply sexp
              eqSet
              (map (|val| (annotate val "a"    )) eqSet)
              (map (|val| (annotate val "b"    )) eqSet)
              (map (|val| (annotate val "a" "c")) eqSet)
              accum))))
      (sexp)
  (append_m
    // Nulls are their own equivalence sets
    (apply mutable_list (map sexp all_nulls))
    (list
      (sexp VOID)
      (sexp UNDEF)
      (sexp eof)
      (sexp true)
      (sexp false)
      (sexp "")
      (sexp "true")
      (sexp (quote 'true'))
      (sexp 1)
      (sexp 1.)
      (sexp 1.0)
      (sexp 1.00)
      (sexp 0)
      (sexp 0.)
      (sexp -0.)
      (sexp 0.00)
      (sexp -0.00)
      (sexp 0e0)
      (sexp -0e0)
      (sexp 2014T)
      (sexp 2014-01T)
      (sexp 2014-01-01T)
      (sexp 2014-01-01T00:00Z)
      (sexp 2014-01-01T02:00+02:00)
      (sexp {{}})
      (sexp {{""}})
      (sexp {{Zm9vYmFy}})
      (sexp {{"foobar"}})
      (sexp (pair 1 2))
      (sexp (pair 1.0 2.0))
      (sexp (pair 1. 2.000))
      (sexp (pair null 1))
      (sexp (pair null.int 1))
      (sexp [] (mutable_list) (stretchy_list))
      (sexp (quote ()) (sexp))
      (sexp [null])
      (sexp [null.int] (mutable_list null.int) (stretchy_list null.int))
      (sexp (sexp null))
      (sexp (sexp null.int))
      (sexp (sexp NULL_SEXP))
      (sexp [null, 1])
      (sexp [null.int, 1.0])
      (sexp [null.int, 1. ])
      (sexp [NULL_SEXP, 1.00])
      (sexp (sexp null 1))
      (sexp (sexp null.int 1.0) (sexp null.int 1.0))
      (sexp [1])
      (sexp [1.0])
      (sexp [1.00])
      (sexp (sexp 1))
      (sexp (sexp 1.0))
      (sexp (sexp 1.00))
      (sexp [1 , true, [2.0]])
      (sexp [1 , (quote a::true), [2.0]])
      (sexp [1 , true, [2.00]])
      (sexp [1., true, [2.0]])
      (sexp [1.0, true, [2.00]])
      (sexp [1.00, true, [2.0]])
      (sexp (sexp 1 true [2.0]))
      (sexp (sexp 1 true [2.00]))

      (sexp {} (struct) (mutable_struct))
      (sexp {f:1})
      (sexp {f:1.0})
      (sexp {f:1.00})
      (sexp {f:1, g:2})
      (sexp {g:2.0, f:1.0})
      (sexp {g:2.0, f:(quote a::1.0)})
      (sexp {f:1.00, g:2.00})
      (sexp {f:1, f:2})
      (sexp {f:1.0, f:2.0})
      (sexp {f:2, f:1.000})
      (sexp {f:1., g:9, f:2, f:2})
      (sexp {f:2, f:1.0, g:9, f:2})
    )))))
